<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#60a5fa">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="光·遇 事件">
    <meta name="description" content="光遇事件时间表">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icons/logo-192.png">
    <link rel="icon" href="./icons/favicon.png" type="image/png">
    <title>光·遇 事件</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="./libs/font-awesome/css/font-awesome.min.css" rel="stylesheet">
    <script src="./libs/@supabase/supabase-js/dist/umd/supabase.js"></script>
    
    <!-- 百度统计代码 -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a9fb76643856176a07e757d16260ac9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <script>
        // 延迟预加载切换国服和破晓日历页面
        window.addEventListener('load', function() {
            setTimeout(function() {
                // 预加载切换国服页面
                var link163 = document.createElement('link');
                link163.rel = 'prefetch';
                link163.href = 'https://sky-event.pages.dev/';
                document.head.appendChild(link163);
                
                // 预加载破晓日历页面
                var linkHHS = document.createElement('link');
                linkHHS.rel = 'prefetch';
                linkHHS.href = 'hhs.html';
                document.head.appendChild(linkHHS);
            }, 3000); // 3秒后预加载
            
            // 添加窗口大小变化事件监听器，确保特殊通知容器与主容器等宽
            // 确保syncNotificationWidth函数已定义
            document.addEventListener('DOMContentLoaded', function() {
                if (typeof syncNotificationWidth === 'function') {
                    window.addEventListener('resize', syncNotificationWidth);
                }
            });
        });
    </script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        priority: {
                            high: '#ef4444',
                            medium: '#f59e0b',
                            low: '#10b981',
                            none: '#64748b'
                        },
                        primary: '#60a5fa',
                        secondary: '#94a3b8',
                        dark: {
                            bg: '#1e293b',
                            card: '#334155',
                            hover: '#475569',
                            text: '#f8fafc',
                            textSecondary: '#cbd5e1'
                        }
                    },
                    fontFamily: {
                        inter: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .task-transition {
                transition: all 0.5s ease-in-out;
            }
            .hover-expand {
                transition: max-height 0.5s ease-in-out;
            }
            .context-menu {
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }
            .modal-backdrop {
                backdrop-filter: blur(2px);
            }
            .app-compact {
                padding: 1.5rem;
                min-height: auto !important;
                width: auto !important;
                min-width: 0 !important;
                max-width: 280px;
            }
            .app-expanded {
                padding: 1.5rem 2rem 1rem 2rem;
                width: auto !important;
                min-width: 0 !important;
                max-width: 520px;
            }
            .task-item {
                cursor: pointer;
            }
            .day-checkbox {
                width: 1.5rem;
                height: 1.5rem;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .recurrence-option {
                @apply p-3 border border-gray-600 rounded-lg cursor-pointer transition-all hover:border-primary;
            }
            .recurrence-option.selected {
                @apply border-primary bg-primary/10;
            }
            .ongoing-indicator {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.6; }
                100% { opacity: 1; }
            }
            .time-input-group {
                @apply flex items-center gap-3;
            }
            .time-input {
                @apply w-20 px-3 py-2 border border-gray-600 rounded-lg bg-dark-card text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent;
            }
            .time-select {
                @apply flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-card text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent;
            }
            .countdown {
                @apply text-xs font-medium px-2 py-0.5 rounded-lg;
                background-color: rgba(96, 165, 250, 0.2);
                color: var(--primary-color);
            }
            .download-btn {
                @apply fixed bottom-6 right-6 bg-primary hover:bg-primary/90 text-white p-1 w-8 h-8 rounded-full shadow-lg transition-all duration-300 flex items-center justify-center z-[9999];
            }
            .download-tooltip {
                @apply absolute right-full mr-3 px-3 py-1 rounded-lg text-sm opacity-0 invisible transition-all duration-300 whitespace-nowrap;
            }
            .download-container:hover .download-tooltip {
                @apply opacity-100 visible;
            }
            .notification {
                @apply fixed top-4 right-4 bg-primary text-white px-4 py-2 rounded-2xl shadow-lg z-[10000] transform transition-all duration-300 translate-x-full;
            }
            .notification.show {
                @apply translate-x-0;
            }
            .notification.error {
                @apply bg-red-500;
            }
            .save-btn {
                @apply fixed bottom-6 left-6 bg-green-600 hover:bg-green-700 text-white p-1 w-8 h-8 rounded-full shadow-lg transition-all duration-300 flex items-center justify-center z-[9999];
            }
            .save-tooltip {
                @apply absolute left-full ml-3 px-3 py-1 rounded-lg text-sm opacity-0 invisible transition-all duration-300 whitespace-nowrap;
            }
            .save-container:hover .save-tooltip {
                @apply opacity-100 visible;
            }
            .save-status {
                @apply fixed bottom-6 left-20 bg-dark-card text-dark-text px-3 py-1 rounded-lg text-sm z-40;
            }
            .task-title {
                @apply tracking-wide;
            }
            .task-meta {
                @apply tracking-tight mt-1.5;
            }
            .task-meta-item {
                @apply mr-3 last:mr-0;
            }
            .ongoing-text {
                @apply font-medium;
                color: var(--ongoing-color) !important;
            }
            
            /* 破晓红石事件地点名称样式 - 提高优先级 */
            .dawn-redstone-location {
                color: var(--primary-color) !important;
            }
            
            /* 浅色模式下破晓红石地点名称颜色 - 确保优先级 */
            body [data-theme="light"] .dawn-redstone-location,
            [data-theme="light"] .task-title .dawn-redstone-location,
            [data-theme="light"] .task-meta .dawn-redstone-location,
            [data-theme="light"] .dawn-redstone-location {
                color: #FF6B8B !important;
            }
            
            /* 深色模式下破晓红石地点名称颜色 */
            body [data-theme="dark"] .dawn-redstone-location,
            [data-theme="dark"] .task-title .dawn-redstone-location,
            [data-theme="dark"] .task-meta .dawn-redstone-location,
            [data-theme="dark"] .dawn-redstone-location {
                color: #60a5fa !important;
            }
            .lock-indicator {
                @apply absolute top-4 right-4 text-dark-textSecondary hover:text-primary transition-colors cursor-pointer;
            }
            
            /* 锁定指示器图标（包括HHS和服务器切换）始终显示为24px */
            .lock-indicator img {
                width: 22px !important;
                height: 22px !important;
            }
            
            /* 电脑端增大显示 */
            @media (min-width: 641px) {
                /* 增大主题切换按钮和图标 */
                .theme-toggle {
                    @apply p-1.5 w-10 h-10 flex items-center justify-center;
                }
                .theme-toggle img {
                    width: 20px !important;
                    height: 20px !important;
                }
                
                /* 季蜡、大蜡、红石和黑石图标 */
                #magic-icons-container img,
                #redstone-blackstone-container img {
                    width: 42px !important;
                    height: 42px !important;
                }
            }
            .lock-indicator.locked {
                @apply text-primary;
            }
            .empty-hover-area {
                cursor: pointer;
                @apply hover:bg-dark-hover/30 transition-colors rounded-2xl;
            }
            .scrollable-list {
                max-height: 500px;
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: var(--scrollbar-color) var(--bg-color);
            }
            .scrollable-list::-webkit-scrollbar {
                width: 6px;
            }
            .scrollable-list::-webkit-scrollbar-track {
                background: var(--bg-color);
                border-radius: 3px;
            }
            .scrollable-list::-webkit-scrollbar-thumb {
                background-color: var(--scrollbar-color);
                border-radius: 3px;
            }
            
            /* 全局隐藏滚动条但保留滚动功能 */
            html, body {
                scrollbar-width: none; /* Firefox */
            }
            
            html::-webkit-scrollbar,
            body::-webkit-scrollbar {
                display: none; /* Chrome, Edge, Safari */
            }
            /* 预览卡片样式 - 紧凑优化版本 */
            .preview-card {
                @apply fixed bg-dark-card rounded-2xl shadow-2xl border-2 border-primary/50 p-3 max-w-xs z-50 transform transition-all duration-200 scale-95 opacity-0 pointer-events-none;
                backdrop-filter: blur(10px);
                min-width: 260px;
            }
            .preview-card.show {
                @apply scale-100 opacity-100 pointer-events-auto;
            }
            .preview-card::before {
                content: '';
                @apply absolute -top-2 left-4 w-4 h-4 bg-primary/50 transform rotate-45;
            }
            .preview-content {
                @apply space-y-1.5;
            }
            .preview-header {
                @apply flex justify-between items-center mb-2 pb-2 border-b border-gray-700;
            }
            .preview-name {
                @apply font-medium text-dark-text flex items-center text-sm;
            }
            .preview-status {
                @apply text-xs text-primary flex items-center;
            }
            .preview-details {
                @apply text-xs text-dark-textSecondary space-y-1;
            }
            .preview-row {
                @apply flex justify-between items-center;
            }
            .preview-icon {
                @apply w-3 h-3 mr-1.5 opacity-70 flex items-center justify-center;
            }
            .preview-label {
                @apply flex items-center mr-2;
            }
            .preview-value {
                @apply text-dark-text text-right;
            }
            .preview-highlight {
                animation: glow 2s ease-in-out infinite alternate;
            }
            @keyframes glow {
                from {
                    box-shadow: 0 0 5px var(--primary-color), 0 0 10px var(--primary-color);
                }
                to {
                    box-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
                }
            }
            

            /* 丝滑跟随效果 */
            .preview-smooth {
                transition: transform 0.1s ease-out, opacity 0.2s ease-out;
            }
            /* 任务激活状态 */
            .future-task-item.active {
                @apply bg-primary bg-opacity-10 border-primary;
            }
            /* 主题切换按钮 */
            .theme-toggle {
                z-index: 40;
                transition: all 0.3s ease;
            }
            
            /* 主题变量定义 - 樱花配色 */
            :root {
                /* 默认深色主题 */
                --bg-color: #1e293b;
                --card-color: #334155;
                --text-color: #f8fafc;
                --text-secondary: #cbd5e1;
                --hover-color: #475569;
                --border-color: #64748b;
                --primary-color: #60a5fa;
                --priority-high: #ef4444;
                --priority-medium: #f59e0b;
                --priority-low: #10b981;
                --priority-none: #64748b;
            }
            
            [data-theme="light"] {
                /* 樱花配色 - 浅色主题 */
                --bg-color: #FFF5F7 !important;
                --card-color: #FFFFFF !important;
                --text-color: #3D1A2D !important;
                --text-secondary: #8A4A62 !important;
                --hover-color: #FFF0F3 !important;
                --border-color: #FFD6E0 !important;
                --primary-color: #60a5fa !important;
                --scrollbar-color: #FFB7C5 !important;
                --ongoing-color: #FF6B8B !important;
                --countdown-color: #60a5fa !important;
                --priority-high: #FF6B8B !important;
                --priority-medium: #FFA7C4 !important;
                --priority-low: #FFD6E0 !important;
                --priority-none: #D8BFD8 !important;
            }
            
            /* 独立的预览卡片呼吸阴影样式 - 只影响阴影不影响其他颜色 */
            [data-theme="light"] .preview-highlight {
                animation-name: glow-light;
            }
            
            @keyframes glow-light {
                from {
                    box-shadow: 0 0 5px #FFB7C5, 0 0 10px #FFB7C5;
                }
                to {
                    box-shadow: 0 0 10px #FFB7C5, 0 0 20px #FFB7C5;
                }
            }
            
            [data-theme="dark"] {
                --bg-color: #1e293b !important;
                --card-color: #334155 !important;
                --text-color: #f8fafc !important;
                --text-secondary: #cbd5e1 !important;
                --hover-color: #475569 !important;
                --border-color: #64748b !important;
                --primary-color: #60a5fa !important;
                --scrollbar-color: #60a5fa !important;
                --ongoing-color: #ef4444 !important;
                --countdown-color: #60a5fa !important;
                --priority-high: #ef4444 !important;
                --priority-medium: #f59e0b !important;
                --priority-low: #10b981 !important;
                --priority-none: #64748b !important;
            }
            
            [data-theme="dark"] .countdown {
                color: #60a5fa;
            }
            
            [data-theme="light"] .countdown {
                color: #FF6B8B !important;
            }
            
            /* 词条提示器样式 - 深色主题 */
            html[data-theme="dark"] .download-tooltip,
            html[data-theme="dark"] .save-tooltip {
                background-color: #334155 !important;
                color: #f8fafc !important;
            }
            
            /* 词条提示器样式 - 浅色主题 */
            html[data-theme="light"] .download-tooltip,
            html[data-theme="light"] .save-tooltip {
                background-color: #FF6B8B !important;
                color: #ffffff !important;
            }
            
            /* 应用主题变量 - 覆盖所有相关元素 */
            body {
                background-color: var(--bg-color) !important;
                color: var(--text-color) !important;
            }
            
            /* 按钮样式 - 深色主题 */
            html[data-theme="dark"] .download-btn,
            html[data-theme="dark"] .save-btn {
                background-color: #60a5fa !important;
                color: white !important;
            }
            
            /* 按钮样式 - 浅色主题 */
            html[data-theme="light"] .download-btn,
            html[data-theme="light"] .save-btn {
                background-color: #FFA7C4 !important;
                color: white !important;
            }
            
            /* 覆盖所有卡片背景 */
            .bg-dark-card,
            #app-container,
            .preview-card,
            .modal-content {
                background-color: var(--card-color) !important;
            }
            
            /* 主题切换按钮 - 确保背景色为白色 */
            .theme-toggle {
                background-color: var(--card-color) !important;
                color: var(--text-color) !important;
                border-color: var(--border-color) !important;
            }
            
            /* 覆盖所有文本颜色 */
            .text-dark-text,
            h1, h2, h3, h4, h5, h6,
            p,
            span,
            label,
            .task-title,
            .task-meta,
            .task-time,
            .modal-title {
                color: var(--text-color) !important;
            }
            
            /* 覆盖所有次要文本颜色 */
            .text-dark-textSecondary,
            .task-meta span,
            .task-time,
            .save-status {
                color: var(--text-secondary) !important;
            }
            
            /* 通知元素样式 - 深色主题 */
            html[data-theme="dark"] .notification {
                background-color: #60a5fa !important;
                color: white !important;
            }
            
            /* 通知元素样式 - 浅色主题 */
            html[data-theme="light"] .notification {
                background-color: #FFA7C4 !important;
                color: white !important;
            }
            
            /* 特殊通知容器主题背景色 */
            [data-theme="dark"] #special-notification {
                background-color: #182130 !important;
            }
            
            [data-theme="light"] #special-notification {
                background-color: #ffd6e09f !important;
            }
            
            /* 隐藏特殊通知容器的滚动条 */
            #special-notification {
                scrollbar-width: none; /* Firefox */
                position: relative;
                overflow-x: auto !important; /* 确保水平滚动生效 */
            }
            
            #special-notification::-webkit-scrollbar {
                display: none; /* Chrome, Edge, Safari */
            }
            

            
            .notification.error {
                background-color: #ef4444 !important;
                color: white !important;
            }
            
            /* 覆盖所有悬停背景 */
            .bg-dark-hover,
            .bg-dark-hover:hover,
            .task-item:hover,
            .task-item.selected,
            button:hover,
            .recurrence-option.selected {
                background-color: var(--hover-color) !important;
            }
            
            /* 覆盖所有边框颜色 */
            .border-gray-600,
            .border-gray-700,
            #app-container,
            .preview-card,
            .modal-content,
            .task-item,
            input,
            select,
            textarea,
            .time-input-group {
                border-color: var(--border-color) !important;
            }
            
            /* 覆盖所有主色 */
            .bg-primary,
            button[type="submit"],
            .download-btn,
            .download-btn:hover,
            .save-btn:hover {
                background-color: var(--primary-color) !important;
            }
            
            /* 保存按钮样式 - 浅色主题下使用浅绿色 */
            [data-theme="light"] .save-btn {
                background-color: #10b981 !important;
            }
            
            [data-theme="dark"] .save-btn {
                background-color: var(--priority-low) !important;
            }
            
            /* 加载指示器样式 - 深色主题 */
            html[data-theme="dark"] .loading-indicator {
                color: #60a5fa !important;
            }
            
            /* 加载指示器样式 - 浅色主题 */
            html[data-theme="light"] .loading-indicator {
                color: #FFA7C4 !important;
            }
            .text-primary,
            .text-primary span:not(.ongoing-text):not(.countdown) {
                color: var(--primary-color) !important;
            }
            

            
            /* 覆盖优先级颜色 */
            .text-priority-high,
            .priority-high {
                color: var(--priority-high) !important;
            }
            .bg-priority-high {
                background-color: var(--priority-high) !important;
            }
            
            .text-priority-medium,
            .priority-medium {
                color: var(--priority-medium) !important;
            }
            
            .text-priority-low,
            .priority-low {
                color: var(--priority-low) !important;
            }
            
            /* 覆盖背景色类 */
            .bg-dark-bg {
                background-color: var(--bg-color) !important;
            }
            
            .text-priority-none {
                color: var(--priority-none) !important;
            }
            
            /* 添加CSS变量到根元素，确保所有元素都能访问 */
            :root {
                /* 默认深色主题 */
                --bg-color: #1e293b;
                --card-color: #334155;
                --text-color: #f8fafc;
                --text-secondary: #cbd5e1;
                --hover-color: #475569;
                --border-color: #64748b;
                --primary-color: #60a5fa;
                --priority-high: #ef4444;
                --priority-medium: #f59e0b;
                --priority-low: #10b981;
                --priority-none: #64748b;
            }
            
            /* 浅色主题覆盖 */
            [data-theme="light"] {
                --bg-color: #FFF5F7;
                --card-color: #FFFFFF;
                --text-color: #3D1A2D;
                --text-secondary: #8A4A62;
                --hover-color: #FFF0F3;
                --border-color: #FFD6E0;
                --primary-color: #60a5fa;
                --priority-high: #FF6B8B;
                --priority-medium: #FFA7C4;
                --priority-low: #FFD6E0;
                --priority-none: #D8BFD8;
            }
            
            /* 深色主题覆盖 */
            [data-theme="dark"] {
                --bg-color: #1e293b;
                --card-color: #334155;
                --text-color: #f8fafc;
                --text-secondary: #cbd5e1;
                --hover-color: #475569;
                --border-color: #64748b;
                --primary-color: #60a5fa;
                --priority-high: #ef4444;
                --priority-medium: #f59e0b;
                --priority-low: #10b981;
                --priority-none: #64748b;
            }
            /* 手机端优化 */
            @media (max-width: 640px) {
                /* 调整主题切换按钮和魔法图标更靠左 */
                .theme-toggle-container:not(.right-icons-container) {
                    left: 6px !important;
                }
                /* 确保右侧图标容器始终在右侧 */
                .right-icons-container {
                    right: 6px !important;
                }
                
                /* 保持主题按钮和魔法图标之间的适当距离 */
                .theme-toggle-container > div.h-8 {
                    height: 24px !important; /* 增大距离 */
                }
                
                /* 进一步减少魔法图标之间的间距，使其更紧凑 */
            #magic-icons-container,
            #redstone-blackstone-container {
                gap: 1px !important; /* 魔法图标内部更紧凑 */
                margin-top: 0 !important; /* 移除负margin */
            }
            
            /* 调整魔法、大蜡、季蜡、红石和黑石图标的大小，使其更紧凑 */
            #magic-icons-container img,
            #redstone-blackstone-container img {
                width: 34px !important;
                height: 34px !important;
            }
                
                /* 调整主题切换按钮大小，与季蜡等图标一致 */
                .theme-toggle {
                    @apply p-2 w-[34px] h-[34px] flex items-center justify-center;
                }
                
                /* 调整主题切换按钮图标大小，保持比例合适 */
                .theme-toggle img {
                    width: auto !important;
                    height: auto !important;
                    max-width: 18px !important;
                    max-height: 18px !important;
                    object-fit: contain !important;
                }
                
                /* 确保特殊通知容器在手机上与桌面一致的底部边距 */
                #special-notification {
                    margin-bottom: 0.25rem !important;
                }
                
                .app-expanded {
                    padding: 1rem;
                    max-width: 100%;
                    min-height: auto !important;
                }
                .app-compact {
                    padding: 1rem;
                    max-width: 100%;
                }
                .preview-card {
                    max-width: 85vw;
                    min-width: 0;
                    left: 7.5vw !important;
                    right: 7.5vw;
                    transform-origin: center;
                }
                .preview-card::before {
                    display: none;
                }
                .task-meta {
                    @apply flex flex-col gap-1;
                }
                .task-meta-item {
                    @apply mr-0;
                }
                .time-input-group {
                    @apply flex-col items-stretch;
                }
                .time-input, .time-select {
                    @apply w-full;
                }
                .download-btn, .save-btn {
                    @apply bottom-4 p-0.5 w-7 h-7;
                }
                .download-btn {
                    right: 12px;
                }
                .save-btn {
                    left: 12px;
                }
                .save-status {
                    @apply bottom-4 left-16;
                }
                .modal-content {
                    @apply max-h-[90vh] overflow-y-auto;
                }
                .task-item {
                    @apply p-3;
                }
                .task-title {
                    @apply text-sm;
                }
                .task-meta {
                    @apply text-xs;
                }
            }
        }

        /* 主题变量定义 */
        :root {
            /* 暗黑主题变量 */
            --bg-color: #1e293b;
            --card-color: #334155;
            --text-color: #f8fafc;
            --text-secondary: #cbd5e1;
            --hover-color: #475569;
            --border-color: #4b5563;
            --primary-color: #60a5fa;
            --priority-high: #ef4444;
            --priority-medium: #f59e0b;
            --priority-low: #10b981;
            --priority-none: #64748b;
        }

        [data-theme="dark"] {
            --bg-color: #1e293b;
            --card-color: #334155;
            --text-color: #f8fafc;
            --text-secondary: #cbd5e1;
            --hover-color: #475569;
            --border-color: #64748b;
            --primary-color: #60a5fa;
            --priority-high: #ef4444;
            --priority-medium: #f59e0b;
            --priority-low: #10b981;
            --priority-none: #64748b;
        }

        [data-theme="light"] {
            --bg-color: #f5f5f5;
            --card-color: #ffffff;
            --text-color: #1e293b;
            --text-secondary: #64748b;
            --hover-color: #f1f5f9;
            --border-color: #e2e8f0;
            --primary-color: #3b82f6;
            --priority-high: #dc2626;
            --priority-medium: #d97706;
            --priority-low: #059669;
            --priority-none: #6b7280;
        }

        /* 应用主题变量 */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-y: auto; /* 允许竖向滚动 */
        }
        
        /* 全局隐藏滚动条但保留滚动功能 */
        html, body {
            scrollbar-width: none; /* Firefox：隐藏竖向滚动条 */
        }
        
        html::-webkit-scrollbar, body::-webkit-scrollbar {
            display: none; /* Chrome, Edge, Safari：隐藏所有滚动条 */
        }

        .bg-dark-bg {
            background-color: var(--bg-color) !important;
        }

        .bg-dark-card {
            background-color: var(--card-color) !important;
        }

        .text-dark-text {
            color: var(--text-color) !important;
        }

        .text-dark-textSecondary {
            color: var(--text-secondary) !important;
        }

        .bg-dark-hover:hover {
            background-color: var(--hover-color) !important;
        }

        .border-gray-700 {
            border-color: var(--border-color) !important;
        }

        /* 确保其他元素也支持主题切换 */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.6);
        }

        .context-menu {
            background-color: var(--card-color);
            border-color: var(--border-color);
        }

        .preview-card {
            background-color: var(--card-color);
            border-color: var(--primary-color);
        }

        .empty-hover-area {
            background-color: transparent;
        }

        .empty-hover-area:hover {
            background-color: var(--hover-color);
        }

        /* 系统主题检测备用 */
        @media (prefers-color-scheme: dark) {
            :root:not([data-theme]) {
                --bg-color: #1e293b;
                --card-color: #334155;
                --text-color: #f8fafc;
                --text-secondary: #cbd5e1;
                --hover-color: #475569;
                --border-color: #64748b;
            }
        }
        
        @media (prefers-color-scheme: light) {
            :root:not([data-theme]) {
                --bg-color: #f8fafc;
                --card-color: #ffffff;
                --text-color: #1e293b;
                --text-secondary: #64748b;
                --hover-color: #f1f5f9;
                --border-color: #e2e8f0;
            }
        }
    </style>
    <script>
        // 主题初始化 - 在DOM加载前设置主题，避免颜色闪烁
        (function() {
            const storedTheme = localStorage.getItem('theme');
            // 检测系统主题偏好，如果没有存储的主题
            let initialTheme = storedTheme;
            if (!initialTheme) {
                // 检查系统主题偏好
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    initialTheme = 'dark';
                } else {
                    initialTheme = 'light'; // 默认使用浅色主题
                }
            }
            document.documentElement.setAttribute('data-theme', initialTheme);
        })();
    </script>
</head>
<body class="bg-dark-bg min-h-screen flex items-center justify-center p-4 font-inter text-dark-text m-0">
    <!-- 主题切换按钮 -->
    <div class="theme-toggle-container fixed top-4 left-4 z-40 flex flex-col items-center rounded-2xl">
        <button id="theme-toggle" class="theme-toggle p-2 rounded-2xl bg-dark-card border border-gray-700 text-dark-text hover:bg-dark-hover transition-colors shadow-lg" title="切换主题">
            <img src="./icons/moon.png" id="theme-icon" alt="切换主题" style="width: 16px; height: 16px;" />
        </button>
        
        <!-- 间隔区域 -->
        <div class="h-8"></div>
        
        <!-- 魔法图标显示区域 -->
        <div id="magic-icons-container" class="space-y-1 flex flex-col items-center">
            <!-- 魔法图标将通过JavaScript动态添加 -->
        </div>
    </div>

    <!-- 右侧红石黑石图标容器 -->
    <div class="theme-toggle-container right-icons-container fixed top-4 right-4 z-40 flex flex-col items-center rounded-2xl">
        <div class="theme-toggle p-2 rounded-2xl bg-transparent border-none text-dark-text hover:bg-transparent transition-colors shadow-none" style="visibility: hidden;">
            <div style="width: 16px; height: 16px;"></div>
        </div>
        <div class="h-8"></div>
        <div id="redstone-blackstone-container" class="space-y-1 flex flex-col items-center"></div>
    </div>

    <!-- 加载指示器 -->
    <div id="loading-indicator" class="fixed inset-0 flex items-center justify-center bg-dark-bg z-50 transition-opacity duration-500">
<div class="loading-indicator text-2xl font-bold animate-pulse">Sky 事件 时间</div>
    </div>
    
    <!-- 主内容包装容器 -->
    <div class="flex flex-col items-center justify-center w-full">
        <!-- 特殊通知容器 -->
        <div id="special-notification" class="relative min-h-[34px] w-full max-w-[520px] overflow-x-auto overflow-y-hidden whitespace-nowrap bg-dark-card rounded-2xl mb-3 text-center text-sm text-red-600 flex items-center justify-center hidden mx-auto px-4"></div>
        
        <div id="app-container" class="bg-dark-card rounded-2xl shadow-lg task-transition border border-gray-700 w-auto max-w-md app-expanded relative opacity-0 translate-y-4 transition-all duration-800">
        <div id="lock-indicator" class="lock-indicator" title="破晓 日历">
            <a href="hhs.html" target="_self" class="text-dark-textSecondary hover:text-primary transition-colors" id="hhs-link">
                <img src="icons/hs.png" alt="Lock" style="width: 20px; height: 20px;">
            </a>
        </div>
        

        
        <!-- 添加163图标链接 -->
        <div id="163-icon" class="lock-indicator" style="right: auto; left: 1rem;" title="切换国际服">
            <a href="https://sky-event.pages.dev/" target="_self" class="text-dark-textSecondary hover:text-primary transition-colors">
                <img src="icons/zg.svg" alt="163" style="width: 20px; height: 20px;">
            </a>
        </div>
        
        <div id="current-time" class="text-center text-2xl font-semibold text-dark-text mb-4"></div>
        
        <div id="tasks-container" class="relative min-h-[80px] overflow-hidden">
            <div id="task-carousel" class="transition-transform duration-500 ease-in-out">
            </div>
        </div>
        
        <div class="text-sm text-dark-textSecondary mb-1 font-medium text-center empty-hover-area p-2">
            未来事件
        </div>
        
        <div id="all-tasks" class="mt-0 max-h-0 overflow-hidden hover-expand">
            <div id="all-tasks-list" class="space-y-2.5 text-sm scrollable-list"></div>
        </div>
        
        <div id="controls-container" class="flex justify-center mt-4 space-x-2 transition-all duration-300 hidden">
        </div>
    </div>
    </div>

    <!-- 预览卡片 - 紧凑优化排版 -->
    <div id="preview-card" class="preview-card preview-smooth">
        <div class="preview-content">
            <div class="preview-header">
                <div class="preview-name">
                    <span id="preview-priority" class="w-2 h-2 rounded-full mr-2"></span>
                    <span id="preview-name" class="truncate"></span>
                </div>
                <div id="preview-status" class="preview-status"></div>
            </div>
            <div class="preview-details">
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-repeat preview-icon"></i>
                        <span>重复</span>
                    </span>
                    <span id="preview-recurrence" class="preview-value"></span>
                </div>
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-clock-o preview-icon"></i>
                        <span>时长</span>
                    </span>
                    <span id="preview-duration" class="preview-value"></span>
                </div>
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-calendar preview-icon"></i>
                        <span>日期</span>
                    </span>
                    <span id="preview-date" class="preview-value"></span>
                </div>
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-hourglass-start preview-icon"></i>
                        <span>时间</span>
                    </span>
                    <span id="preview-time" class="preview-value"></span>
                </div>
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-map-marker preview-icon"></i>
                        <span>地点</span>
                    </span>
                    <span id="preview-location" class="preview-value"></span>
                </div>
                <div class="preview-row">
                    <span class="preview-label">
                        <i class="fa fa-bell preview-icon"></i>
                        <span>提醒</span>
                    </span>
                    <span id="preview-alert" class="preview-value"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- 右键菜单 -->
    <div id="main-context-menu" class="context-menu hidden absolute bg-dark-card rounded-lg shadow-lg p-2 w-48 border border-gray-700">
        <div id="add-task-option" class="px-4 py-2 text-sm text-dark-text hover:bg-dark-hover rounded cursor-pointer">
            <i class="fa fa-plus mr-2 text-primary"></i>添加新事件
        </div>
    </div>

    <div id="task-context-menu" class="context-menu hidden absolute bg-dark-card rounded-lg shadow-lg p-2 w-48 border border-gray-700">
        <div id="edit-task-option" class="px-4 py-2 text-sm text-dark-text hover:bg-dark-hover rounded cursor-pointer">
            <i class="fa fa-pencil mr-2 text-primary"></i>编辑事件
        </div>
        <div id="delete-task-option" class="px-4 py-2 text-sm text-dark-text hover:bg-dark-hover rounded cursor-pointer">
            <i class="fa fa-trash mr-2 text-red-500"></i>删除事件
        </div>
    </div>

    <!-- 确认删除模态框 -->
    <div id="confirm-delete-modal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-backdrop absolute inset-0 bg-black bg-opacity-60"></div>
        <div class="bg-dark-card rounded-xl shadow-xl p-6 w-full max-w-md relative z-10 transform transition-all border border-gray-700 modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-dark-text">确认删除</h3>
                <button id="close-delete-modal" class="text-dark-textSecondary hover:text-dark-text">
                    <i class="fa fa-times"></i>
                </button>
            </div>
            
            <p class="text-dark-textSecondary mb-6">您确定要删除这个事件吗？此操作无法撤销。</p>
            
            <div class="flex justify-end space-x-3">
                <button id="cancel-delete" class="px-4 py-2 border border-gray-600 rounded-lg text-dark-text hover:bg-dark-hover transition-colors">取消</button>
                <button id="confirm-delete" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                    确认删除
                </button>
            </div>
        </div>
    </div>

    <!-- 添加/编辑事件模态框 -->
    <div id="task-modal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-backdrop absolute inset-0 bg-black bg-opacity-60"></div>
        <div class="bg-dark-card rounded-xl shadow-xl p-6 w-full max-w-md relative z-10 transform transition-all border border-gray-700 modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-lg font-semibold text-dark-text">添加新事件</h3>
                <button id="close-modal" class="text-dark-textSecondary hover:text-dark-text">
                    <i class="fa fa-times"></i>
                </button>
            </div>
            
            <form id="task-form">
                <input type="hidden" id="task-id">
                
                <div class="mb-4">
                    <label for="task-name" class="block text-sm font-medium text-dark-textSecondary mb-1">事件名称</label>
                    <input type="text" id="task-name" name="task-name" required class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                </div>
                
                <div class="mb-4">
                    <label for="task-priority" class="block text-sm font-medium text-dark-textSecondary mb-1">优先级</label>
                    <select id="task-priority" name="task-priority" required class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                        <option value="high">高 (红色)</option>
                        <option value="medium" selected>中 (黄色)</option>
                        <option value="low">低 (绿色)</option>
                        <option value="none">无 (灰色)</option>
                    </select>
                </div>
                
                <div class="mb-4">
                    <label for="task-location" class="block text-sm font-medium text-dark-textSecondary mb-1">地点</label>
                    <input type="text" id="task-location" name="task-location" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                    <p class="text-xs text-primary mt-1">事件发生的地点，可选填</p>
                </div>
                
                <div class="mb-4">
                    <label for="display-threshold" class="block text-sm font-medium text-dark-textSecondary mb-1">提前提醒时间</label>
                    <div class="time-input-group">
                        <input type="number" id="display-threshold" name="display-threshold" min="1" value="10" class="time-input">
                        <select id="display-threshold-unit" name="display-threshold-unit" class="time-select">
                            <option value="minute">分钟</option>
                            <option value="hour">小时</option>
                            <option value="day">天</option>
                            <option value="week">周</option>
                        </select>
                    </div>
                    <p class="text-xs text-primary mt-1">事件开始前多久显示提醒</p>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">重复方式</label>
                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <div class="recurrence-option selected" data-type="none">
                            <div class="font-medium">不重复</div>
                            <div class="text-xs text-dark-textSecondary">仅一次</div>
                        </div>
                        <div class="recurrence-option" data-type="daily">
                            <div class="font-medium">每天</div>
                            <div class="text-xs text-dark-textSecondary">每天固定时间</div>
                        </div>
                        <div class="recurrence-option" data-type="weekly">
                            <div class="font-medium">每周</div>
                            <div class="text-xs text-dark-textSecondary">每周特定日期</div>
                        </div>
                        <div class="recurrence-option" data-type="monthly">
                            <div class="font-medium">每月</div>
                            <div class="text-xs text-dark-textSecondary">每月特定日期</div>
                        </div>
                        <div class="recurrence-option" data-type="interval">
                            <div class="font-medium">间隔</div>
                            <div class="text-xs text-dark-textSecondary">按固定间隔</div>
                        </div>
                        <div class="recurrence-option" data-type="monthly_interval">
                            <div class="font-medium">每月+间隔</div>
                            <div class="text-xs text-dark-textSecondary">每月特定日期内按间隔重复</div>
                        </div>
                    </div>
                    <input type="hidden" id="recurrence-type" value="none">
                </div>
                
                <!-- 不重复选项 -->
                <div id="none-options" class="mb-4 bg-dark-bg p-3 rounded-lg border border-gray-600 none-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始时间</label>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <input type="date" id="start-date" name="start-date" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-date">
                            <label for="start-date" class="text-xs text-dark-textSecondary">日期</label>
                        </div>
                        <div>
                            <input type="time" id="start-time" name="start-time" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time">
                            <label for="start-time" class="text-xs text-dark-textSecondary">时间</label>
                        </div>
                    </div>
                </div>
                
                <!-- 每天重复选项 -->
                <div id="daily-options" class="mb-4 hidden bg-dark-bg p-3 rounded-lg border border-gray-600 daily-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始日期</label>
                    <div class="mb-3">
                        <input type="date" id="daily-start-date" name="daily-start-date" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-date">
                    </div>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">重复类型</label>
                    <div class="mb-3">
                        <select id="daily-repeat-type" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <option value="time-points">特定时间点</option>
                            <option value="time-range">时间段重复</option>
                        </select>
                    </div>
                    <!-- 特定时间点重复选项 -->
                    <div id="daily-time-points" class="mb-3">
                        <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始时间</label>
                        <div id="daily-times-container" class="time-container space-y-2">
                            <div class="time-input-group flex items-center gap-2">
                                <input type="time" name="daily-start-time" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time-input">
                                <button type="button" class="remove-time-btn text-red-500 hover:text-red-600">
                                    <i class="fa fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <button type="button" id="add-daily-time" class="mt-2 text-sm text-primary hover:text-primary/80 add-time-btn">
                            <i class="fa fa-plus"></i> 添加时间
                        </button>
                    </div>
                    <!-- 时间段重复选项 -->
                    <div id="daily-time-range" class="mb-3 hidden">
                        <div class="grid grid-cols-2 gap-3 mb-2">
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">开始时间</label>
                                <input type="time" id="daily-range-start" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">结束时间</label>
                                <input type="time" id="daily-range-end" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">间隔时间</label>
                                <input type="number" id="daily-range-interval" min="1" value="1" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">时间单位</label>
                                <select id="daily-range-unit" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option value="minute">分钟</option>
                                    <option value="hour" selected>小时</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 每周重复选项 -->
                <div id="weekly-options" class="mb-4 hidden bg-dark-bg p-3 rounded-lg border border-gray-600 weekly-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">每周重复日期</label>
                    <div class="weekday-checkboxes flex flex-wrap gap-2 mb-3">
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="1" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">一</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="2" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">二</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="3" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">三</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="4" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">四</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="5" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">五</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="6" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">六</span>
                        </label>
                        <label class="day-checkbox bg-dark-card border border-gray-600 hover:bg-dark-hover cursor-pointer">
                            <input type="checkbox" name="weekday" value="0" class="hidden peer">
                            <span class="text-xs peer-checked:text-primary">日</span>
                        </label>
                    </div>
                    
                    <!-- 重复类型选择 -->
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">重复类型</label>
                    <select id="weekly-repeat-type" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent mb-2">
                        <option value="time-points">特定时间点</option>
                        <option value="time-range">时间段</option>
                    </select>
                    
                    <!-- 时间点重复选项 -->
                    <div id="weekly-time-points">
                        <label class="block text-sm font-medium text-dark-textSecondary mb-2">每周特定时间点 (最少有一个)</label>
                        <div id="weekly-times-container" class="time-container space-y-2">
                            <div class="time-input-group flex items-center gap-2">
                                <input type="time" name="weekly-start-time" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time-input">
                                <button type="button" class="remove-time-btn text-red-500 hover:text-red-600">
                                    <i class="fa fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <button type="button" id="add-weekly-time" class="mt-2 text-sm text-primary hover:text-primary/80 add-time-btn">
                            <i class="fa fa-plus"></i> 添加时间
                        </button>
                        <p class="text-xs text-primary mt-1">每周在这些时间点重复事件</p>
                    </div>
                    
                    <!-- 时间段重复选项 -->
                    <div id="weekly-time-range" class="hidden">
                        <label class="block text-sm font-medium text-dark-textSecondary mb-2">时间段</label>
                        <div class="flex gap-2 mb-2">
                            <input type="time" id="weekly-range-start" name="weekly-range-start" class="w-1/2 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="开始时间">
                            <span class="flex items-center">-</span>
                            <input type="time" id="weekly-range-end" name="weekly-range-end" class="w-1/2 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="结束时间">
                        </div>
                        <label class="block text-sm font-medium text-dark-textSecondary mb-2">间隔</label>
                        <div class="flex gap-2">
                            <input type="number" id="weekly-range-interval" name="weekly-range-interval" min="1" value="1" class="w-1/3 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <select id="weekly-range-unit" name="weekly-range-unit" class="w-2/3 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                                <option value="minute">分钟</option>
                                <option value="hour" selected>小时</option>
                                <option value="day">天</option>
                            </select>
                        </div>
                        <p class="text-xs text-primary mt-1">每周在指定时间段内按间隔重复事件</p>
                    </div>
                </div>
                
                <!-- 每月重复选项 -->
                <div id="monthly-options" class="mb-4 hidden bg-dark-bg p-3 rounded-lg border border-gray-600 monthly-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始日期</label>
                    <div id="monthly-dates-container" class="date-container space-y-2 mb-3">
                        <div class="date-input-group flex items-center gap-2">
                            <input type="number" name="monthly-start-date" min="1" max="31" value="1" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-date-input">
                            <button type="button" class="remove-date-btn text-red-500 hover:text-red-600">
                                <i class="fa fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <button type="button" id="add-monthly-date" class="mb-3 text-sm text-primary hover:text-primary/80 add-date-btn">
                        <i class="fa fa-plus"></i> 添加日期
                    </button>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">重复类型</label>
                    <div class="mb-3">
                        <select id="monthly-repeat-type" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <option value="time-points">特定时间点</option>
                            <option value="time-range">时间段重复</option>
                        </select>
                    </div>
                    <!-- 特定时间点重复选项 -->
                    <div id="monthly-time-points" class="mb-3">
                        <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始时间</label>
                        <div id="monthly-times-container" class="time-container space-y-2">
                            <div class="time-input-group flex items-center gap-2">
                                <input type="time" name="monthly-start-time" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time-input">
                                <button type="button" class="remove-time-btn text-red-500 hover:text-red-600">
                                    <i class="fa fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <button type="button" id="add-monthly-time" class="mt-2 text-sm text-primary hover:text-primary/80 add-time-btn">
                            <i class="fa fa-plus"></i> 添加时间
                        </button>
                    </div>
                    <!-- 时间段重复选项 -->
                    <div id="monthly-time-range" class="mb-3 hidden">
                        <div class="grid grid-cols-2 gap-3 mb-2">
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">开始时间</label>
                                <input type="time" id="monthly-range-start" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">结束时间</label>
                                <input type="time" id="monthly-range-end" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">间隔时间</label>
                                <input type="number" id="monthly-range-interval" min="1" value="1" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-xs text-dark-textSecondary mb-1">时间单位</label>
                                <select id="monthly-range-unit" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option value="minute">分钟</option>
                                    <option value="hour" selected>小时</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 间隔重复选项 -->
                <div id="interval-options" class="mb-4 hidden bg-dark-bg p-3 rounded-lg border border-gray-600 interval-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始时间</label>
                    <div class="grid grid-cols-2 gap-3 mb-3">
                        <div>
                            <input type="date" id="interval-start-date" name="interval-start-date" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-date">
                            <label class="text-xs text-dark-textSecondary">日期</label>
                        </div>
                        <div>
                            <input type="time" id="interval-start-time" name="interval-start-time" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time">
                            <label class="text-xs text-dark-textSecondary">时间</label>
                        </div>
                    </div>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">结束时间</label>
                    <div class="grid grid-cols-2 gap-3 mb-3">
                        <div>
                            <input type="date" id="interval-end-date" name="interval-end-date" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent end-date">
                            <label class="text-xs text-dark-textSecondary">日期</label>
                        </div>
                        <div>
                            <input type="time" id="interval-end-time" name="interval-end-time" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent end-time">
                            <label class="text-xs text-dark-textSecondary">时间</label>
                        </div>
                    </div>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">重复间隔</label>
                    <div class="time-input-group">
                        <input type="number" id="interval-count" name="interval-count" min="1" value="1" class="time-input interval-count">
                        <select id="interval-unit" name="interval-unit" class="time-select interval-unit">
                            <option value="minute">分钟</option>
                            <option value="hour">小时</option>
                            <option value="day">天</option>
                            <option value="week">周</option>
                            <option value="month">月</option>
                        </select>
                    </div>
                </div>

                <!-- 每月+间隔重复选项 -->
                <div id="monthly_interval-options" class="mb-4 hidden bg-dark-bg p-3 rounded-lg border border-gray-600 monthly_interval-options">
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">开始时间</label>
                    <div>
                        <input type="time" id="monthly_interval-start-time" name="monthly_interval-start-time" class="w-full px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent start-time">
                    </div>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">选择日期</label>
                    <div class="grid grid-cols-7 gap-2 mb-3">
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="1" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>1</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="2" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>2</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="3" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>3</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="4" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>4</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="5" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>5</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="6" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>6</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="7" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>7</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="8" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>8</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="9" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>9</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="10" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>10</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="11" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>11</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="12" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>12</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="13" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>13</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="14" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>14</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="15" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>15</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="16" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>16</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="17" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>17</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="18" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>18</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="19" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>19</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="20" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>20</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="21" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>21</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="22" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>22</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="23" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>23</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="24" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>24</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="25" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>25</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="26" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>26</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="27" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>27</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="28" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>28</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="29" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>29</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="30" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>30</span>
                        </label>
                        <label class="flex items-center gap-1">
                            <input type="checkbox" name="monthly_interval-day" value="31" class="rounded border-gray-600 bg-dark-bg text-primary focus:ring-primary">
                            <span>31</span>
                        </label>
                    </div>
                    <label class="block text-sm font-medium text-dark-textSecondary mb-2">当天间隔设置</label>
                    <div class="flex gap-3">
                        <input type="number" id="monthly_interval-count" name="monthly_interval-count" min="1" value="4" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                        <select id="monthly_interval-unit" name="monthly_interval-unit" class="flex-1 px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent">
                            <option value="minute">分钟</option>
                            <option value="hour" selected>小时</option>
                            <option value="day">天</option>
                        </select>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="task-duration" class="block text-sm font-medium text-dark-textSecondary mb-1">持续时间</label>
                    <div class="time-input-group">
                        <input type="number" id="task-duration" name="task-duration" min="1" value="10" class="time-input">
                        <select id="duration-unit" name="duration-unit" class="time-select">
                            <option value="minute">分钟</option>
                            <option value="hour">小时</option>
                            <option value="day">天</option>
                            <option value="week">周</option>
                            <option value="month">月</option>
                        </select>
                    </div>
                    <p class="text-xs text-primary mt-1">事件进行的时长，将作为进行中事件的倒计时基准</p>
                </div>
                
                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" id="cancel-task" class="px-4 py-2 border border-gray-600 rounded-lg text-dark-text hover:bg-dark-hover transition-colors">取消</button>
                    <button type="submit" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">
                        保存事件
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- 下载按钮 -->
    <div class="download-container relative">
        <button id="download-btn" class="download-btn">
            <img src="icons/an.png" alt="下载">
        </button>

    </div>

    <!-- 保存按钮 -->
    
    <!-- 拉花喷射效果canvas -->
    <canvas id="spray-canvas"></canvas>
    
    <style>
        #spray-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            pointer-events: none;
        }
        
        #app-container {
            z-index: 2;
            position: relative;
        }
    </style>
    
    <script>
        // 拉花喷射效果实现
        const canvas = document.getElementById('spray-canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置画布大小为窗口大小
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // 初始化画布大小
        resizeCanvas();
        
        // 窗口大小改变时重新调整画布大小
        window.addEventListener('resize', resizeCanvas);
        
        // 光斑数组
        const spots = [];
        
        // 光斑类
        class Spot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                
                // 添加立体效果：z轴深度属性
                // 使用平方分布使更多光斑生成在远处（数值更大），看起来更小
                this.z = Math.random() * Math.random() * 100 + 50; // 50-150的深度值，更多光斑集中在远处，看起来更小
                const depthFactor = 200 / (this.z + 50); // 深度因子，近大远小
                
                // 【控制光斑大小的核心代码】
                // 通过屏幕宽度检测是否为电脑端（大于640px为电脑端）
                const isDesktop = window.innerWidth > 640;
                // 电脑端: 2-6的基础大小，移动端: 2-4的基础大小（比电脑端小一点）
                const baseSize = isDesktop ? (Math.random() * 4 + 2) : (Math.random() * 2 + 2);
                this.initialSize = baseSize * depthFactor; // 应用深度缩放，实现近大远小效果
                this.size = this.initialSize; // 记录初始大小，用于实现增大效果
                this.color = this.getRandomColor();
                
                // 计算屏幕中上区域的目标点（自适应屏幕尺寸）
                const targetX = canvas.width / 1.8; // 屏幕水平中心
                // 电脑端时垂直方向0%位置（屏幕最上边缘），移动端时25%位置
                const targetY = isDesktop ? 0 : canvas.height * 0.10;
                
                // 计算从起始点到目标点的角度
                let angle = Math.atan2(targetY - this.y, targetX - this.x);
                
                // 使用高斯分布实现非均匀角度分布，使光斑更集中在中间区域
                // 高斯分布函数
                function gaussianRandom() {
                    let u = 0, v = 0;
                    while(u === 0) u = Math.random(); // 转换[0,1)到(0,1]
                    while(v === 0) v = Math.random();
                    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                }
                
                // 喷射角度偏差参数：控制光斑扩散程度
                const angleDeviation = gaussianRandom() * 0.02;
                angle += angleDeviation * Math.PI; // 添加随机偏差，保持扩散效果
                
                // 喷射速度参数：控制爆发力和高度
                // 电脑端使用更高的基础速度，移动端保持原速度
                const baseSpeed = isDesktop ? 130 : 50;
                const speed = Math.random() * 3 + baseSpeed; // 电脑端: 80-83, 移动端: 50-53的速度范围，数值越大喷射高度越高
                
                // 根据深度调整速度，远处的光斑移动更慢，增强视差效果
                const speedFactor = 1 / (this.z / 100); // 近处速度快，远处速度慢
                this.speedX = Math.cos(angle) * speed * speedFactor; // x方向速度
                this.speedY = Math.sin(angle) * speed * speedFactor; // y方向速度（向上）
                
                // 物理属性参数 - 添加随机变化实现不同降落速度
                this.gravity = Math.random() * 0.15 + 0.13; // 随机重力加速度：0.15-0.3，数值越大下落越快
                this.airResistance = Math.random() * 0.03 + 0.88; // 随机空气阻力：0.88-0.95，数值越大减速越慢
                
                // 雪花飘动效果参数
                this.waveOffset1 = Math.random() * Math.PI * 2;
                this.waveOffset2 = Math.random() * Math.PI * 2;
                // 主要摇摆幅度，数值越大左右摇摆越明显
                // 电脑端最小值为1，移动端最小值为0.9
                // 复用前面已经声明的isDesktop变量
                this.waveAmplitude1 = Math.random() * 1.5 + (isDesktop ? 1.5 : 0.5);
                this.waveAmplitude2 = Math.random() * 0.8 + 0.2; // 次要摇摆幅度，数值越大上下摇摆越明显
                this.waveFrequency1 = Math.random() * 0.018 + 0.01; // 主要摇摆频率，数值越大摇摆速度越快
                this.waveFrequency2 = Math.random() * 0.015 + 0.005; // 次要摇摆频率，数值越大摇摆速度越快
                
                // 动画控制参数
                this.frameCount = 0; // 记录光斑已存在的帧数，用于控制大小变化动画
                this.totalGrowthFrames = 300; // 光斑完成最大增长所需的帧数（可根据需要调整，数值越大增长越慢）
                this.totalGrowthFactor = 1.3; // 总增大比例（50%），保持固定确保线性增长
                
                // 雪花旋转效果参数
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02; // 旋转速度
                
                // 不规则形状属性参数
                this.irregularity = Math.random() * 0.15 + 0.15; // 不规则程度，数值越大形状越不规则
                this.spikes = Math.floor(Math.random() * 6) + 10; // 10-15个尖刺，数值越大尖刺越多
                
                // 【光斑透明度控制的核心代码】
                // 电脑端: 90%-100%透明度，移动端: 95%-100%透明度（稍微提高一点，解决视觉错觉问题）
                this.opacity = Math.random() * 0.1 + (isDesktop ? 0.9 : 0.95);
                
                // 随机落地消失阈值，使每个光斑在不同高度消失
                // 大部分光斑在屏幕内消失，只有少部分在屏幕外消失
                // 90%的光斑在屏幕内底部50-150像素开始消失，10%的光斑在屏幕外0-100像素开始消失
                this.groundThreshold = canvas.height - (Math.random() > 0.1 ? (Math.random() * 100 + 50) : (-Math.random() * 100)); // 距离屏幕底部50-150像素(90%)或屏幕外0-100像素(10%)的随机位置开始消失
                
                // 对于近处的光斑（z值较小），确保透明度达到70%
                if (this.z < 150) {
                    this.opacity = Math.max(this.opacity, 0.9); // 确保近处光斑达到90%透明度，数值越大近处光斑越明显
                }
                
                // 添加随机变色速度系数，使不同光斑颜色变化不同步
                this.colorSpeedFactor = Math.random() * 0.6 + 0.7; // 0.7-1.3的随机系数，控制颜色变化速度
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(255, 255, 255, ',   // 白色 - 主要雪花颜色
                    'rgba(240, 248, 255, ',    // 爱丽丝蓝
                    'rgba(255, 255, 240, ',    // 象牙白
                    'rgba(251, 177, 202, ',     // 红色（带颜色渐变效果） - #FBB1CA
                    'rgba(0, 191, 255, ',      // 蓝色
                    'rgba(251, 177, 202, ',     // 红色（带颜色渐变效果，增加出现概率） - #FBB1CA
                    'rgba(0, 191, 255, ',      // 蓝色（增加出现概率）
                    'rgba(255, 255, 255, '     // 白色
                ];
                // 随机选择颜色，现在红色和蓝色会有更高的出现概率
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                // 检查是否为红色或蓝色光斑，如果是则标记为可渐变颜色
                this.isGradientColor = (color.includes('251, 177, 202') || color.includes('0, 191, 255'));
                
                // 记录初始颜色类型，用于区分渐变方案
                this.isBlueGradient = color.includes('0, 191, 255');
                
                return color;
            }
            
            update() {
                // 应用空气阻力
                this.speedX *= this.airResistance;
                this.speedY *= this.airResistance;
                
                // 应用重力
                this.speedY += this.gravity;
                
                // 计算雪花飘动效果 - 使用双重正弦波实现更自然的飘动
                const waveX = Math.sin(this.frameCount * this.waveFrequency1 + this.waveOffset1) * this.waveAmplitude1 +
                              Math.sin(this.frameCount * this.waveFrequency2 + this.waveOffset2) * this.waveAmplitude2 * 0.5;
                const waveY = Math.cos(this.frameCount * this.waveFrequency1 + this.waveOffset1) * this.waveAmplitude1 * 0.3 +
                              Math.cos(this.frameCount * this.waveFrequency2 + this.waveOffset2) * this.waveAmplitude2 * 0.2;
                
                // 更新位置
                this.x += this.speedX + waveX;
                this.y += this.speedY + waveY;
                
                // 更新旋转
                this.rotation += this.rotationSpeed;
                
                // 光斑线性稳定变大效果：从创建开始就立即开始线性增长动画
                this.frameCount++;
                
                // 使用帧数计算增长进度，实现精确的线性增长
                // Math.min 确保进度不会超过100%
                const growthProgress = Math.min(this.frameCount / this.totalGrowthFrames, 1);
                
                // 线性增长公式：当前大小 = 初始大小 + (初始大小 * 增长比例 * 增长进度)
                // 这个公式确保增长速度完全线性且稳定
                this.size = this.initialSize * (1 + (this.totalGrowthFactor - 1) * growthProgress);
                
                // 为红色和蓝色光斑添加颜色渐变效果
                if (this.isGradientColor) {
                    // 计算生命周期进度（从0到1），应用随机变色速度系数
                    const lifeProgress = Math.min(this.frameCount / (this.totalGrowthFrames * 1.5 * this.colorSpeedFactor), 1);
                    
                    let r, g, b;
                    
                    if (this.isBlueGradient) {
                        // 蓝色光斑渐变：白色 -> #25BDF8 -> #9370DB -> #25BDF8
                        // 白色：255, 255, 255
                        // #25BDF8：37, 189, 248
                        // #9370DB (中紫色)：147, 112, 219
                        if (lifeProgress < 0.25) {
                            // 第一阶段：白色 (255, 255, 255) 到 #25BDF8 (37, 189, 248)
                            const phaseProgress = lifeProgress / 0.25;
                            r = Math.floor(255 - (255 - 37) * phaseProgress); // 红色分量从255降到37
                            g = Math.floor(255 - (255 - 189) * phaseProgress); // 绿色分量从255降到189
                            b = Math.floor(255 - (255 - 248) * phaseProgress); // 蓝色分量从255降到248
                        } else if (lifeProgress < 0.5) {
                            // 第二阶段：#25BDF8 (37, 189, 248) 到 #9370DB (147, 112, 219)
                            const phaseProgress = (lifeProgress - 0.25) / 0.25;
                            r = Math.floor(37 + (147 - 37) * phaseProgress); // 红色分量从37升到147
                            g = Math.floor(189 + (112 - 189) * phaseProgress); // 绿色分量从189降到112
                            b = Math.floor(248 + (219 - 248) * phaseProgress); // 蓝色分量从248降到219
                        } else if (lifeProgress < 0.75) {
                            // 第三阶段：#9370DB (147, 112, 219) 到 #25BDF8 (37, 189, 248)
                            const phaseProgress = (lifeProgress - 0.5) / 0.25;
                            r = Math.floor(147 - (147 - 37) * phaseProgress); // 红色分量从147降到37
                            g = Math.floor(112 - (112 - 189) * phaseProgress); // 绿色分量从112升到189
                            b = Math.floor(219 + (248 - 219) * phaseProgress); // 蓝色分量从219升到248
                        } else {
                            // 第四阶段：#25BDF8 (37, 189, 248) 保持不变
                            r = 37; // 红色分量保持37
                            g = 189; // 绿色分量保持189
                            b = 248; // 蓝色分量保持248
                        }
                    } else {
                        // 红色光斑渐变：#FBB1CA -> #ffe1f1ff -> #ff7300f5 -> #FBB1CA
                        // #FBB1CA 的 RGB 值：251, 177, 202
                        // #ffe1f1ff 的 RGB 值：255, 225, 241
                        // #ff7300f5 的 RGB 值：240, 130, 20 (降低颜色深度后)
                        if (lifeProgress < 0.33) {
                            // 第一阶段：#FBB1CA (251, 177, 202) 到 #ffe1f1ff (255, 225, 241)
                            const phaseProgress = lifeProgress / 0.33; // 0-1 映射到 0-1
                            r = Math.floor(251 + 4 * phaseProgress); // 红色分量从251升到255
                            g = Math.floor(177 + 48 * phaseProgress); // 绿色分量从177升到225
                            b = Math.floor(202 + 39 * phaseProgress); // 蓝色分量从202升到241
                        } else if (lifeProgress < 0.66) {
                            // 第二阶段：#ffe1f1ff (255, 225, 241) 到 #ff7300f5 (255, 115, 0)
                            const phaseProgress = (lifeProgress - 0.33) / 0.33; // 0.33-0.66 映射到 0-1
                            r = 255; // 红色分量保持不变
                            g = Math.floor(225 - 95 * phaseProgress); // 绿色分量从225降到130
                            b = Math.floor(241 - 221 * phaseProgress); // 蓝色分量从241降到20
                        } else {
                            // 第三阶段：#ff7300f5 (255, 115, 0) 到 #FBB1CA (251, 177, 202)
                            const phaseProgress = (lifeProgress - 0.66) / 0.34; // 0.66-1 映射到 0-1
                            r = Math.floor(255 - 4 * phaseProgress); // 红色分量从255降到251
                            g = Math.floor(130 + 47 * phaseProgress); // 绿色分量从130升到177
                            b = Math.floor(20 + 182 * phaseProgress); // 蓝色分量从20升到202
                        }
                    }
                    
                    // 更新光斑颜色
                    this.color = `rgba(${r}, ${g}, ${b}, `;
                }
                
                // 快落地时逐渐消失效果（随机阈值）
                if (this.y > this.groundThreshold) {
                    // 计算距离各自消失阈值的相对距离（0-1）
                    const distanceToGround = (this.y - this.groundThreshold) / 100;
                    // 透明度随距离增加而衰减，每个光斑衰减速度略有不同
                    this.opacity *= Math.max(0, 1 - distanceToGround * (Math.random() * 0.5 + 1.5)); // 透明度衰减速度，数值越大消失越快
                    // 保持光斑继续增大，不再缩小，增强持续变大的视觉效果
                    // this.size *= Math.max(0.5, 1 - distanceToGround * (Math.random() * 0.2 + 0.3)); // 注释掉缩小效果
                }
            }
            
            draw() {
                ctx.save();
                
                // 设置透明度
                ctx.globalAlpha = this.opacity;
                
                // 应用旋转效果
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.translate(-this.x, -this.y);
                
                // 绘制不规则圆形光斑（雪花形状）
                // 使用径向渐变实现虚化边缘，不增加额外光晕效果
                this.drawIrregularCircle(ctx, this.x, this.y, this.size);
                
                ctx.restore();
            }
            
            // 绘制不规则圆形的方法
            drawIrregularCircle(ctx, x, y, radius) {
                const points = [];
                const angleStep = Math.PI * 2 / this.spikes;
                
                for (let i = 0; i < Math.PI * 2; i += angleStep) {
                    const randomRadius = radius * (1 + Math.random() * this.irregularity - this.irregularity / 2);
                    const px = x + Math.cos(i) * randomRadius;
                    const py = y + Math.sin(i) * randomRadius;
                    points.push({ x: px, y: py });
                }
                
                // 绘制平滑的不规则形状
                ctx.beginPath();
                
                // 使用修改后的贝塞尔曲线方法创建更平滑的形状
                for (let i = 0; i < points.length; i++) {
                    const curr = points[i];
                    const next = points[(i + 1) % points.length];
                    const nextNext = points[(i + 2) % points.length];
                    
                    // 计算中点
                    const mx1 = (curr.x + next.x) / 2;
                    const my1 = (curr.y + next.y) / 2;
                    const mx2 = (next.x + nextNext.x) / 2;
                    const my2 = (next.y + nextNext.y) / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(mx1, my1);
                    } else {
                        ctx.quadraticCurveTo(next.x, next.y, mx2, my2);
                    }
                }
                
                ctx.closePath();
                
                // 使用径向渐变填充，设置适度的边缘虚化效果
                // 在之前两次修改之间找到平衡的衰减曲线
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, this.color + '1)'); // 中心完全不透明
                gradient.addColorStop(0.65, this.color + '0.9)'); // 65%半径处90%不透明（中间值）
                gradient.addColorStop(0.95, this.color + '0.4)'); // 95%半径处40%不透明（中间值）
                gradient.addColorStop(1, this.color + '0.2)'); // 边缘20%不透明（中间值）
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            isDead() {
                // 判断光斑是否完全超出屏幕范围或透明度为0
                // 增加向下消失范围，允许光斑在屏幕底部下方200像素内消失
                return this.y - this.size > canvas.height + 200 || 
                       this.x + this.size < -100 || 
                       this.x - this.size > canvas.width + 100 ||
                       this.opacity <= 0.05; // 透明度阈值，数值越小光斑存活时间越长
            }
        }
        
        // 在指定位置喷射光斑（通用函数）
        function spraySpotsAtPosition(x, y) {
            // 通过屏幕宽度检测是否为电脑端（大于768px为电脑端）
            const isDesktop = window.innerWidth > 640;
            
            // 一次创建多个光斑，模拟雪花飘落效果
            let spotCount = Math.floor(Math.random() * 42) + 98; // 98-140个光斑（增加40%），数值越大喷射越密集，增加更多小光斑
            
            // 电脑端时光斑数量翻倍
            if (isDesktop) {
                spotCount *= 3;
            }
            
            for (let i = 0; i < spotCount; i++) {
                // 初始位置的随机性，使雪花从指定位置散开
                const offsetX = (Math.random() - 0.5) * 10; // X方向初始位置偏移，数值越大初始扩散范围越广
                const offsetY = (Math.random() - 0.5) * 10; // Y方向初始位置偏移，数值越大初始扩散范围越广
                spots.push(new Spot(x + offsetX, y + offsetY));
            }
        }
        
        // 喷射光斑函数
        function spraySpots() {
            // 获取下载按钮的位置信息
            if (typeof downloadBtn === 'undefined') {
                downloadBtn = document.getElementById('download-btn');
            }
            if (downloadBtn) {
                const btnRect = downloadBtn.getBoundingClientRect();
                // 将起点设置在下载按钮附近
                const x = btnRect.left + btnRect.width / 2;
                const y = btnRect.top + btnRect.height / 2;
                spraySpotsAtPosition(x, y);
            }
        }
        
        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 按z轴排序光斑，近处的光斑（z值小）在上面绘制
            spots.sort((a, b) => b.z - a.z);
            
            // 更新和绘制光斑
            for (let i = spots.length - 1; i >= 0; i--) {
                const spot = spots[i];
                spot.update();
                spot.draw();
                
                if (spot.isDead()) {
                    spots.splice(i, 1);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // 添加事件监听器
        const btn = document.getElementById('download-btn');
        if (btn) {
            btn.addEventListener('click', spraySpots);
        }
        
        // 开始动画
        animate();
    </script>
    <div class="save-container relative">
        <button id="manual-save-btn" class="save-btn">
            <img src="icons/an.png" alt="保存">
        </button>
    </div>

    <!-- 保存状态 -->
    <div id="save-status" class="save-status hidden">
        <span id="save-status-text">保存中...</span>
    </div>

    <!-- 通知 -->
    <div id="notification" class="notification">数据已保存</div>

    <script>
        // ==================== 主题管理器 ====================
        class ThemeManager {
            constructor() {
                this.currentTheme = this.getStoredTheme() || this.getSystemTheme();
                this.init();
            }
            
            // 初始化主题
            init() {
                this.applyTheme(this.currentTheme);
            }

            // 获取系统主题偏好
            getSystemTheme() {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    return 'dark';
                }
                return 'light';
            }

            // 获取存储的主题
            getStoredTheme() {
                return localStorage.getItem('theme');
            }

            // 保存主题偏好
            saveTheme(theme) {
                localStorage.setItem('theme', theme);
            }

            // 应用主题
            applyTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                this.currentTheme = theme;
                this.updateThemeColor(theme);
                this.updateThemeIcon();
                this.updateTooltips();
                this.saveTheme(theme);
            }
            
            // 更新主题色（影响浏览器地址栏和任务栏）
            updateThemeColor(theme) {
                // 根据主题选择对应的主题色
                const themeColor = theme === 'dark' ? '#1e293b' : '#FFF5F7';
                
                // 更新meta标签
                let themeMeta = document.querySelector('meta[name="theme-color"]');
                if (themeMeta) {
                    themeMeta.setAttribute('content', themeColor);
                }
                
                // 如果在Service Worker环境中，尝试更新manifest
                if (self.registration && 'update' in self.registration) {
                    self.registration.update();
                }
            }

            // 更新词条提示器样式
            updateTooltips() {
                const tooltips = document.querySelectorAll('.download-tooltip, .save-tooltip');
                tooltips.forEach(tooltip => {
                    if (this.currentTheme === 'light') {
                        tooltip.style.backgroundColor = '#FF6B8B';
                        tooltip.style.color = 'var(--card-color)';
                    } else {
                        tooltip.style.backgroundColor = 'var(--card-color)';
                        tooltip.style.color = 'var(--text-color)';
                    }
                });
            }

            // 更新主题图标
            updateThemeIcon() {
                const icon = document.getElementById('theme-icon');
                if (icon) {
                    if (this.currentTheme === 'dark') {
                        icon.src = './icons/sun.png';
                        icon.title = '切换到浅色模式';
                    } else {
                        icon.src = './icons/moon.png';
                        icon.title = '切换到深色模式';
                    }
                }
            }

            // 切换主题
            toggleTheme() {
                const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
                this.applyTheme(newTheme);
                showNotification(`已切换到${newTheme === 'dark' ? '深色' : '浅色'}模式`);
            }

            // 监听系统主题变化
            watchSystemTheme() {
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                        // 只有当用户没有手动设置过主题时才跟随系统
                        if (!this.getStoredTheme()) {
                            this.applyTheme(e.matches ? 'dark' : 'light');
                            showNotification(`已跟随系统切换到${e.matches ? '深色' : '浅色'}模式`);
                        }
                    });
                }
            }

            // 初始化
            init() {
                this.applyTheme(this.currentTheme);
                this.watchSystemTheme();
            }
        }

        // ==================== 时区转换工具 ====================
        const TimeZoneUtils = {
            // 判断当前是否处于太平洋夏令时
            isPDT(date = new Date()) {
                // 太平洋夏令时通常在每年3月第二个星期日凌晨2点开始
                // 到11月第一个星期日凌晨2点结束
                const year = date.getFullYear();
                
                // 计算3月第二个星期日凌晨2点（PDT开始时间）
                const march = new Date(year, 2, 1); // 3月1日
                let secondSundayInMarch = march;
                while (secondSundayInMarch.getDay() !== 0) {
                    secondSundayInMarch.setDate(secondSundayInMarch.getDate() + 1);
                }
                secondSundayInMarch.setDate(secondSundayInMarch.getDate() + 7); // 第二个星期日
                secondSundayInMarch.setHours(2, 0, 0, 0); // 凌晨2点
                
                // 计算11月第一个星期日凌晨2点（PDT结束时间）
                const november = new Date(year, 10, 1); // 11月1日
                let firstSundayInNovember = november;
                while (firstSundayInNovember.getDay() !== 0) {
                    firstSundayInNovember.setDate(firstSundayInNovember.getDate() + 1);
                }
                firstSundayInNovember.setHours(2, 0, 0, 0); // 凌晨2点
                
                // 判断给定日期是否在PDT期间
                return date >= secondSundayInMarch && date < firstSundayInNovember;
            },
            
            // 太平洋时间到北京时间的转换 - 已关闭时区转换功能
            PDTtoCST(pdtDate) {
                return pdtDate; // 直接返回原始日期，不再进行时区转换
            },
            
            // 北京时间到太平洋时间的转换 - 已关闭时区转换功能
            CSTtoPDT(cstDate) {
                return cstDate; // 直接返回原始日期，不再进行时区转换
            },
            
            // 格式化时间为北京时间显示
            formatCSTTime(date) {
                return date.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
            },
            
            // 格式化日期为北京时间显示
            formatCSTDate(date) {
                const today = new Date();
                if (date.toDateString() === today.toDateString()) {
                    return '今天';
                }
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                if (date.toDateString() === tomorrow.toDateString()) {
                    return '明天';
                }
                return date.toLocaleDateString('zh-CN', { 
                    month: 'short', 
                    day: 'numeric', 
                    weekday: 'short' 
                });
            }
        };

        // ==================== 破晓红石事件规则 ====================
        function getDawnRedstoneLocation(date, dayOfWeek) {
            const dayOfMonth = date.getDate();
            
            // 暮土系 (日期: 1,6,11,16,21,26,31)
            if ([1, 6, 11, 16, 21, 26, 31].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return "暮土-黑水港湾";
                if (dayOfWeek === 6) return "暮土-巨兽荒原";
                if (dayOfWeek === 0) return "暮土-失落方舟";
            }
            
            // 禁阁系 (日期: 2,7,12,17,22,27)
            if ([2, 7, 12, 17, 22, 27].includes(dayOfMonth)) {
                if ([5, 6, 0].includes(dayOfWeek)) return "禁阁-星漠海滩";
            }
            
            // 云野系 (日期: 3,8,13,18,23,28)
            if ([3, 8, 13, 18, 23, 28].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return "云野-云顶浮石";
                if (dayOfWeek === 6) return "云野-幽光山洞";
                if (dayOfWeek === 0) return "云野-圣岛";
            }
            
            // 雨林系 (日期: 4,9,14,19,24,29)
            if ([4, 9, 14, 19, 24, 29].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return "雨林-大树屋";
                if (dayOfWeek === 6) return "雨林-雨林神庙";
                if (dayOfWeek === 0) return "雨林-秘密花园";
            }
            
            // 霞谷系 (日期: 5,10,15,20,25,30)
            if ([5, 10, 15, 20, 25, 30].includes(dayOfMonth)) {
                if ([5, 6].includes(dayOfWeek)) return "霞谷-圆梦村";
                if (dayOfWeek === 0) return "霞谷-雪隐峰";
            }
            
            return "未知地点";
        }
        
        // 修复：破晓红石事件特殊规则函数
        function isDawnRedstoneActive(now) {
            const currentDate = now.getDate();
            const currentDay = now.getDay();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentTime = currentHour * 60 + currentMinute;
            
            // 当月的每个周日固定时间段循环事件
            if (currentDay === 0) {
                const timeSlots = [
                    { start: 7*60+8, end: 8*60+0 },
                    { start: 13*60+8, end: 14*60+0 },
                    { start: 19*60+8, end: 20*60+0 }
                ];
                
                for (let slot of timeSlots) {
                    if (currentTime >= slot.start && currentTime < slot.end) {
                        const startTime = new Date(now);
                        startTime.setHours(Math.floor(slot.start/60), slot.start%60, 0, 0);
                        const endTime = new Date(now);
                        endTime.setHours(Math.floor(slot.end/60), slot.end%60, 0, 0);
                        return { 
                            startTime, 
                            endTime,
                            location: getDawnRedstoneLocation(now, currentDay)
                        };
                    }
                }
            }
            
            // 当月的1号到15号内的每个周六固定时间段循环事件
            if (currentDay === 6 && currentDate >= 1 && currentDate <= 15) {
                const timeSlots = [
                    { start: 10*60+8, end: 11*60+0 },
                    { start: 14*60+8, end: 15*60+0 },
                    { start: 22*60+8, end: 23*60+0 }
                ];
                
                for (let slot of timeSlots) {
                    if (currentTime >= slot.start && currentTime < slot.end) {
                        const startTime = new Date(now);
                        startTime.setHours(Math.floor(slot.start/60), slot.start%60, 0, 0);
                        const endTime = new Date(now);
                        endTime.setHours(Math.floor(slot.end/60), slot.end%60, 0, 0);
                        return { 
                            startTime, 
                            endTime,
                            location: getDawnRedstoneLocation(now, currentDay)
                        };
                    }
                }
            }
            
            // 当月的16号到当月底内的每个周五固定时间段循环事件
            if (currentDay === 5 && currentDate >= 16) {
                const timeSlots = [
                    { start: 11*60+8, end: 12*60+0 },
                    { start: 17*60+8, end: 18*60+0 },
                    { start: 23*60+8, end: 24*60+0 }
                ];
                
                for (let slot of timeSlots) {
                    let startTime, endTime;
                    
                    if (slot.end === 24*60) {
                        startTime = new Date(now);
                        startTime.setHours(Math.floor(slot.start/60), slot.start%60, 0, 0);
                        endTime = new Date(now);
                        endTime.setDate(endTime.getDate() + 1);
                        endTime.setHours(0, 0, 0, 0);
                    } else {
                        startTime = new Date(now);
                        startTime.setHours(Math.floor(slot.start/60), slot.start%60, 0, 0);
                        endTime = new Date(now);
                        endTime.setHours(Math.floor(slot.end/60), slot.end%60, 0, 0);
                    }
                    
                    if (now >= startTime && now < endTime) {
                        return { 
                            startTime, 
                            endTime,
                            location: getDawnRedstoneLocation(now, currentDay)
                        };
                    }
                }
            }
            
            return null;
        }
        
        // 修复：计算破晓红石事件的下一次发生时间
        function getNextDawnRedstoneOccurrence(now) {
            const currentActiveInfo = isDawnRedstoneActive(now);
            if (currentActiveInfo) {
                return {
                    startTime: currentActiveInfo.startTime,
                    location: currentActiveInfo.location
                };
            }
            
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            
            const currentDate = now.getDate();
            const currentDay = now.getDay();
            
            const timeSlots = getDawnRedstoneTimeSlots(currentDate, currentDay);
            for (let slot of timeSlots) {
                const slotTime = new Date(today);
                slotTime.setHours(Math.floor(slot.start/60), slot.start%60, 0, 0);
                
                if (slotTime > now) {
                    return {
                        startTime: slotTime,
                        location: getDawnRedstoneLocation(slotTime, slotTime.getDay())
                    };
                }
            }
            
            for (let i = 1; i <= 7; i++) {
                const checkDate = new Date(today);
                checkDate.setDate(checkDate.getDate() + i);
                const checkDay = checkDate.getDay();
                const checkDateNum = checkDate.getDate();
                
                const daySlots = getDawnRedstoneTimeSlots(checkDateNum, checkDay);
                if (daySlots.length > 0) {
                    const firstSlot = daySlots[0];
                    const firstSlotTime = new Date(checkDate);
                    firstSlotTime.setHours(Math.floor(firstSlot.start/60), firstSlot.start%60, 0, 0);
                    return {
                        startTime: firstSlotTime,
                        location: getDawnRedstoneLocation(firstSlotTime, firstSlotTime.getDay())
                    };
                }
            }
            
            const defaultTime = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
            return {
                startTime: defaultTime,
                location: getDawnRedstoneLocation(defaultTime, defaultTime.getDay())
            };
        }
        
        // 获取指定日期的破晓红石时间段
        function getDawnRedstoneTimeSlots(date, day) {
            const slots = [];
            
            if (day === 0) {
                slots.push(
                    { start: 7*60+8, end: 8*60+0 },
                    { start: 13*60+8, end: 14*60+0 },
                    { start: 19*60+8, end: 20*60+0 }
                );
            }
            
            if (day === 6 && date >= 1 && date <= 15) {
                slots.push(
                    { start: 10*60+8, end: 11*60+0 },
                    { start: 14*60+8, end: 15*60+0 },
                    { start: 22*60+8, end: 23*60+0 }
                );
            }
            
            if (day === 5 && date >= 16) {
                slots.push(
                    { start: 11*60+8, end: 12*60+0 },
                    { start: 17*60+8, end: 18*60+0 },
                    { start: 23*60+8, end: 24*60+0 }
                );
            }
            
            return slots;
        }
        


        // ==================== 圆梦滑冰事件规则 ====================
        const DreamSkatingRules = {
            // 检查圆梦滑冰事件是否在活动时间段
            isActive(nowCST) {
                try {
                    const nowPDT = TimeZoneUtils.CSTtoPDT(nowCST);
                    const weekday = nowPDT.getDay(); // 0=周日, 1=周一, ..., 6=周六
                    const hour = nowPDT.getHours();
                    const minute = nowPDT.getMinutes();
                    
                    // 周二、三、四无事件
                    if (weekday === 2 || weekday === 3 || weekday === 4) {
                        return null;
                    }
                    
                    // 计算当前时间是否在活动时间段内
                    let baseHour;
                    if (weekday === 5) { // 周五
                        baseHour = 0; // 太平洋时间00:00 = 北京时间15:00/16:00
                    } else { // 周六、日、一
                        baseHour = 10; // 太平洋时间10:00 = 北京时间次日01:00/02:00
                    }
                    
                    // 每2小时进行一次，持续15分钟
                    const totalMinutes = hour * 60 + minute;
                    const baseMinutes = baseHour * 60;
                    const intervalMinutes = 2 * 60; // 2小时间隔
                    
                    // 计算当前时间相对于基点的间隔数
                    const intervals = Math.floor((totalMinutes - baseMinutes) / intervalMinutes);
                    
                    if (intervals < 0) {
                        return null; // 还没到第一个时间段
                    }
                    
                    const slotStartMinutes = baseMinutes + intervals * intervalMinutes;
                    const slotEndMinutes = slotStartMinutes + 15; // 持续15分钟
                    
                    if (totalMinutes >= slotStartMinutes && totalMinutes < slotEndMinutes) {
                        const slotStartPDT = new Date(nowPDT);
                        slotStartPDT.setHours(Math.floor(slotStartMinutes / 60), slotStartMinutes % 60, 0, 0);
                        const slotEndPDT = new Date(nowPDT);
                        slotEndPDT.setHours(Math.floor(slotEndMinutes / 60), slotEndMinutes % 60, 0, 0);
                        
                        return {
                            startTime: TimeZoneUtils.PDTtoCST(slotStartPDT),
                            endTime: TimeZoneUtils.PDTtoCST(slotEndPDT)
                        };
                    }
                    
                    return null;
                } catch (e) {
                    console.error('检查圆梦滑冰活动状态出错:', e);
                    return null;
                }
            },
            
            // 计算圆梦滑冰事件的下一次发生时间
            getNextOccurrence(nowCST) {
                try {
                    // 首先检查当前是否有正在进行的事件
                    const currentActive = this.isActive(nowCST);
                    if (currentActive) {
                        return {
                            startTime: currentActive.startTime,
                            location: "圆梦村"
                        };
                    }
                    
                    const nowPDT = TimeZoneUtils.CSTtoPDT(nowCST);
                    const weekday = nowPDT.getDay();
                    const hour = nowPDT.getHours();
                    const minute = nowPDT.getMinutes();
                    const totalMinutes = hour * 60 + minute;
                    
                    // 周二、三、四无事件，跳到下一个有效日期
                    if (weekday === 2 || weekday === 3 || weekday === 4) {
                        let nextDate = new Date(nowPDT);
                        let daysToAdd = 1;
                        
                        // 找到下一个有效日期（周五、周六、周日或周一）
                        while (true) {
                            nextDate.setDate(nextDate.getDate() + daysToAdd);
                            const nextWeekday = nextDate.getDay();
                            if (nextWeekday === 5 || nextWeekday === 6 || nextWeekday === 0 || nextWeekday === 1) {
                                break;
                            }
                            daysToAdd++;
                        }
                        
                        const nextWeekday = nextDate.getDay();
                        const baseHour = nextWeekday === 5 ? 0 : 10; // 周五00:00，其他10:00
                        
                        nextDate.setHours(baseHour, 0, 0, 0);
                        return {
                            startTime: TimeZoneUtils.PDTtoCST(nextDate),
                            location: "圆梦村"
                        };
                    }
                    
                    // 当前是有效日期，计算下一个时间段
                    let baseHour;
                    if (weekday === 5) { // 周五
                        baseHour = 0;
                    } else { // 周六、日、一
                        baseHour = 10;
                    }
                    
                    const baseMinutes = baseHour * 60;
                    const intervalMinutes = 2 * 60; // 2小时间隔
                    
                    // 计算下一个时间段
                    let nextSlotMinutes;
                    if (totalMinutes < baseMinutes) {
                        nextSlotMinutes = baseMinutes; // 还没到第一个时间段
                    } else {
                        const intervals = Math.floor((totalMinutes - baseMinutes) / intervalMinutes);
                        nextSlotMinutes = baseMinutes + (intervals + 1) * intervalMinutes;
                    }
                    
                    // 检查下一个时间段是否在同一天
                    const nextHour = Math.floor(nextSlotMinutes / 60);
                    const nextMinute = nextSlotMinutes % 60;
                    
                    if (nextHour < 24) {
                        const nextTimePDT = new Date(nowPDT);
                        nextTimePDT.setHours(nextHour, nextMinute, 0, 0);
                        return {
                            startTime: TimeZoneUtils.PDTtoCST(nextTimePDT),
                            location: "圆梦村"
                        };
                    } else {
                        // 跳到下一天
                        let nextDate = new Date(nowPDT);
                        nextDate.setDate(nextDate.getDate() + 1);
                        let nextWeekday = nextDate.getDay();
                        
                        // 如果下一天是无效日期，继续找
                        while (nextWeekday === 2 || nextWeekday === 3 || nextWeekday === 4) {
                            nextDate.setDate(nextDate.getDate() + 1);
                            nextWeekday = nextDate.getDay();
                        }
                        
                        const nextBaseHour = nextWeekday === 5 ? 0 : 10;
                        nextDate.setHours(nextBaseHour, 0, 0, 0);
                        return {
                            startTime: TimeZoneUtils.PDTtoCST(nextDate),
                            location: "圆梦村"
                        };
                    }
                } catch (e) {
                    console.error('计算圆梦滑冰下次发生时间出错:', e);
                    return {
                        startTime: new Date(nowCST.getTime() + 60 * 60 * 1000),
                        location: "圆梦村"
                    };
                }
            }
        };

        // Supabase 配置
        const supabaseUrl = 'https://prusinqhwaduefiuqkwt.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBydXNpbnFod2FkdWVmaXVxa3d0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQwMTI5OTYsImV4cCI6MjA3OTU4ODk5Nn0.X__p8sP8ZdaOBGsbFWnhAdgLnjTXN-Y8YMVL5csVQ2Y';
        // 创建Supabase客户端实例，添加错误处理以应对CDN加载失败
        let supabase;
        try {
            // 检查CDN加载的Supabase库导出方式
            let createClientFunc = null;
            
            // 1. 检查window.supabase.createClient（CDN UMD版本的正确导出方式）
            if (typeof window.supabase?.createClient === 'function') {
                createClientFunc = window.supabase.createClient;
                console.log('使用window.supabase.createClient初始化Supabase');
            }
            // 2. 检查window.createClient（备选方式）
            else if (typeof window.createClient === 'function') {
                createClientFunc = window.createClient;
                console.log('使用window.createClient初始化Supabase');
            }
            // 3. 检查直接的createClient函数（ES模块方式）
            else if (typeof createClient === 'function') {
                createClientFunc = createClient;
                console.log('使用直接createClient函数初始化Supabase');
            }
            
            if (createClientFunc) {
                supabase = createClientFunc(supabaseUrl, supabaseKey);
                console.log('Supabase客户端初始化成功');
            } else {
                // 如果所有方式都失败，设置supabase为null
                supabase = null;
                console.log('Supabase CDN加载失败或初始化方式不正确，将使用本地存储模式运行');
                console.log('当前window对象:', {
                    hasSupabase: typeof window.supabase !== 'undefined',
                    hasCreateClient: typeof window.createClient === 'function'
                });
            }
        } catch (error) {
            // 捕获任何初始化错误
            supabase = null;
            console.error('Supabase初始化失败:', error);
            console.error('错误堆栈:', error.stack);
        }
        
        // ==================== 核心逻辑 ====================
        
        // 用于存储外部数据的变量
        let externalData = null;
        
        // 保存状态管理
        const saveState = {
            isSaving: false,
            lastSaved: null,
            saveAttempts: 0,
            maxAttempts: 3
        };
        
        // 任务列表锁定状态
        let isListLocked = false;
        
        // 预览卡片状态
        let previewTimeout = null;
        let currentPreviewTaskId = null;
        let isPreviewVisible = false;
        let mouseX = 0;
        let mouseY = 0;
        
        // 存储当前显示的可见任务
        let currentVisibleTasks = [];
        let currentAllTasks = [];
        
        // 获取今天的日期字符串
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // 从外部JSON文件加载硬编数据
        async function loadHardcodedTasks() {
            try {
                const response = await fetch('./hardcoded_tasks.json');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('加载硬编数据失败:', error);
                // 如果加载失败，返回空数组
                return [];
            }
        }

        // 硬编码任务数据变量，将在DOM加载完成后初始化
        let hardcodedTasksData = [];

        // 任务数据 - 所有时间使用太平洋时间，将在DOM加载完成后从硬编数据初始化
        let tasks = [];

        // 当前操作的事件ID
        let currentTaskId = null;

        // DOM元素
        const currentTimeEl = document.getElementById('current-time');
        const taskCarousel = document.getElementById('task-carousel');
        const allTasksEl = document.getElementById('all-tasks');
        const allTasksListEl = document.getElementById('all-tasks-list');
        const appContainer = document.getElementById('app-container');
        const controlsContainer = document.getElementById('controls-container');
        const mainContextMenu = document.getElementById('main-context-menu');
        const taskContextMenu = document.getElementById('task-context-menu');
        const addTaskOption = document.getElementById('add-task-option');
        const editTaskOption = document.getElementById('edit-task-option');
        const deleteTaskOption = document.getElementById('delete-task-option');
        const taskModal = document.getElementById('task-modal');
        const modalTitle = document.getElementById('modal-title');
        const closeModal = document.getElementById('close-modal');
        const cancelTask = document.getElementById('cancel-task');
        const taskForm = document.getElementById('task-form');
        const taskIdInput = document.getElementById('task-id');
        const displayThresholdInput = document.getElementById('display-threshold');
        const displayThresholdUnitInput = document.getElementById('display-threshold-unit');
        const confirmDeleteModal = document.getElementById('confirm-delete-modal');
        const closeDeleteModal = document.getElementById('close-delete-modal');
        const cancelDelete = document.getElementById('cancel-delete');
        const confirmDelete = document.getElementById('confirm-delete');
        const recurrenceTypeInput = document.getElementById('recurrence-type');
        const customOptions = document.getElementById('custom-options');
        const startDateInput = document.getElementById('start-date');
        const startTimeInput = document.getElementById('start-time');
        const intervalCountInput = document.getElementById('interval-count');
        const intervalUnitInput = document.getElementById('interval-unit');
        const taskDurationInput = document.getElementById('task-duration');
        const durationUnitInput = document.getElementById('duration-unit');
        const weekdayCheckboxes = document.querySelectorAll('input[name="weekday"]');
        const monthdayCheckboxes = document.querySelectorAll('input[name="monthday"]');
        const monthweekdayCheckboxes = document.querySelectorAll('input[name="monthweekday"]');
        const recurrenceOptions = document.querySelectorAll('.recurrence-option');
        const downloadBtn = document.getElementById('download-btn');
        const manualSaveBtn = document.getElementById('manual-save-btn');
        const lockIndicator = document.getElementById('lock-indicator');
        const emptyHoverArea = document.querySelector('.empty-hover-area');
        const previewCard = document.getElementById('preview-card');
        const themeToggle = document.getElementById('theme-toggle');
        // 重复选项面板
        const noneOptions = document.querySelector('.none-options');
        const dailyOptions = document.querySelector('.daily-options');
        const weeklyOptions = document.querySelector('.weekly-options');
        const monthlyOptions = document.querySelector('.monthly-options');
        const intervalOptions = document.querySelector('.interval-options');
        const monthly_intervalOptions = document.querySelector('.monthly_interval-options');
        
        // 转换时间单位为毫秒
        function convertToMilliseconds(value, unit) {
            const units = {
                minute: 60 * 1000,
                hour: 60 * 60 * 1000,
                day: 24 * 60 * 60 * 1000,
                week: 7 * 24 * 60 * 60 * 1000,
                month: 30 * 24 * 60 * 60 * 1000
            };
            return value * (units[unit] || units.minute);
        }

        // 同步特殊通知容器与主容器的宽度
        function syncNotificationWidth() {
            const notificationContainer = document.getElementById('special-notification');
            const appContainer = document.getElementById('app-container');
            
            if (notificationContainer && appContainer) {
                const appWidth = appContainer.offsetWidth;
                notificationContainer.style.width = `${appWidth}px`;
            }
        }
        
        // 处理特殊通知容器的显示逻辑
        function updateSpecialNotification() {
            const notificationContainer = document.getElementById('special-notification');
            if (!notificationContainer) return;
            
            // 筛选出ID 15-20的任务
            const specialTasks = tasks.filter(task => task.id >= 15 && task.id <= 20);
            
            console.log('特殊通知调试：符合ID条件的任务数量', specialTasks.length, specialTasks);
            
            // 如果没有符合条件的任务，隐藏容器
            if (specialTasks.length === 0) {
                console.log('特殊通知调试：没有符合条件的任务，隐藏容器');
                notificationContainer.classList.add('hidden');
                return;
            }
            
            // 获取当前时间（CST时区）
            const nowCST = getCurrentTimeCST();
            console.log('特殊通知调试：当前时间（CST）', nowCST);
            
            // 查找在有效时间范围内且有备注的任务
            for (const task of specialTasks) {
                console.log('特殊通知调试：检查任务', task.id, task.name, task.notes);
                
                // 检查任务是否有备注信息
                if (!task.notes || task.notes.trim() === '') {
                    console.log('特殊通知调试：任务备注为空，跳过');
                    continue;
                }
                
                // 检查任务是否在有效时间范围内
                const taskStatus = getTaskStatus(task, nowCST);
                console.log('特殊通知调试：任务状态', taskStatus.status);
                
                // 如果任务在显示范围内（upcoming或ongoing），显示通知
                if (taskStatus.status === 'upcoming' || taskStatus.status === 'ongoing') {
                    console.log('特殊通知调试：任务符合显示条件，显示备注', task.notes);
                    notificationContainer.textContent = task.notes;
                    notificationContainer.classList.remove('hidden');
                    
                    // 检查文本是否超出容器宽度
                    const textWidth = notificationContainer.scrollWidth;
                    const containerWidth = notificationContainer.clientWidth;
                    
                    // 如果文本超出容器宽度，改为左对齐
                    if (textWidth > containerWidth) {
                        notificationContainer.classList.remove('text-center', 'justify-center');
                        notificationContainer.classList.add('text-left', 'justify-start');
                    } else {
                        // 如果文本未超出容器宽度，保持居中对齐
                        notificationContainer.classList.remove('text-left', 'justify-start');
                        notificationContainer.classList.add('text-center', 'justify-center');
                    }
                    
                    // 同步宽度
                    syncNotificationWidth();
                    return;
                } else {
                    console.log('特殊通知调试：任务状态不符合显示条件');
                }
            }
            
            // 如果没有找到符合条件的任务，隐藏容器
            console.log('特殊通知调试：没有找到符合所有条件的任务，隐藏容器');
            notificationContainer.classList.add('hidden');
        }

        // 密码验证功能
        const ADMIN_PASSWORD = 'sky-13'; // 可以修改为更复杂的密码
        
        // 创建密码验证模态对话框的HTML结构
        const passwordModalHTML = `
            <div id="password-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
                <div class="bg-white rounded-lg p-6 w-full max-w-sm shadow-xl">
                    <h3 class="text-lg font-semibold mb-4">请输入管理员密码</h3>
                    <input type="password" id="password-input" class="w-full px-4 py-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="密码">
                    <div class="flex justify-end space-x-2">
                        <button id="password-cancel" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300">取消</button>
                        <button id="password-confirm" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">确认</button>
                    </div>
                </div>
            </div>
        `;
        
        // 将模态对话框添加到body
        document.body.insertAdjacentHTML('beforeend', passwordModalHTML);
        
        // 密码验证模态对话框相关变量
        let passwordResolve = null;
        
        // 绑定事件
        document.getElementById('password-confirm').addEventListener('click', () => {
            const password = document.getElementById('password-input').value;
            document.getElementById('password-modal').classList.add('hidden');
            document.getElementById('password-input').value = '';
            passwordResolve(password === ADMIN_PASSWORD);
        });
        
        document.getElementById('password-cancel').addEventListener('click', () => {
            document.getElementById('password-modal').classList.add('hidden');
            document.getElementById('password-input').value = '';
            passwordResolve(false);
        });
        
        // 允许按Enter键确认
        document.getElementById('password-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('password-confirm').click();
            }
        });
        
        // 验证管理员密码（使用自定义模态对话框）
        async function validatePassword() {
            return new Promise((resolve) => {
                passwordResolve = resolve;
                document.getElementById('password-modal').classList.remove('hidden');
                document.getElementById('password-input').focus();
            });
        }
        
        // 转换毫秒为最适合的单位
        function convertFromMilliseconds(ms) {
            // 处理负数情况
            if (ms < 0) {
                return { value: Math.abs(Math.round(ms / (60 * 1000))), unit: 'minute', text: '分钟' };
            }
            
            if (ms >= 30 * 24 * 60 * 60 * 1000) {
                return { value: Math.round(ms / (30 * 24 * 60 * 60 * 1000)), unit: 'month', text: '月' };
            } else if (ms >= 7 * 24 * 60 * 60 * 1000) {
                return { value: Math.round(ms / (7 * 24 * 60 * 60 * 1000)), unit: 'week', text: '周' };
            } else if (ms >= 24 * 60 * 60 * 1000) {
                return { value: Math.round(ms / (24 * 60 * 60 * 1000)), unit: 'day', text: '天' };
            } else if (ms >= 60 * 60 * 1000) {
                return { value: Math.round(ms / (60 * 60 * 1000)), unit: 'hour', text: '小时' };
            } else {
                return { value: Math.round(ms / (60 * 1000)), unit: 'minute', text: '分钟' };
            }
        }

        // 格式化倒计时显示
        function formatCountdown(ms) {
            if (ms < 0) return "已开始";
            
            const days = Math.floor(ms / (1000 * 60 * 60 * 24));
            const hours = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((ms % (1000 * 60)) / 1000);
            
            if (days > 0) {
                return `${days}天${hours}时`;
            } else if (hours > 0) {
                return `${hours}时${minutes}分`;
            } else if (minutes > 0) {
                return `${minutes}分${seconds}秒`;
            } else {
                return `${seconds}秒`;
            }
        }

        // 合并数据（只使用云端数据，忽略本地缓存）
        function mergeData(localData, remoteData) {
            console.log('开始合并数据:');
            
            // 只使用云端数据，确保界面不显示缓存数据
            let validRemoteData = Array.isArray(remoteData) ? remoteData : [];
            
            // 过滤云端数据中的异常任务
            validRemoteData = validRemoteData.filter(task => {
                if (!task || typeof task.id !== 'number') {
                    console.warn('过滤掉云端异常任务（无效ID或任务对象）:', task);
                    return false;
                }
                if (task.id < -2147483648 || task.id > 2147483647) {
                    console.warn('过滤掉云端ID超出范围的任务 (ID:', task.id, '):', task.name);
                    return false;
                }
                return true;
            });
            
            console.log('云端数据:', validRemoteData.length);
            
            // 直接返回处理后的云端数据，完全忽略本地缓存
            console.log('忽略本地缓存，只使用云端数据');
            
            // 按ID排序
            validRemoteData.sort((a, b) => a.id - b.id);
            
            console.log('合并完成，共', validRemoteData.length, '个任务（仅使用云端数据）');
            return validRemoteData;
        }
        
        // 从Supabase加载数据
        async function loadFromSupabase() {
            console.log('=== 开始从Supabase加载数据 ===');
            try {
                // 详细检查Supabase初始化状态
                console.log('Supabase初始化状态检查:');
                console.log('  supabase变量:', typeof supabase);
                if (supabase) {
                    console.log('  supabase.from方法:', typeof supabase.from);
                    console.log('  supabase变量完整:', supabase);
                }
                
                // 检查supabase是否已正确初始化
                if (!supabase || typeof supabase.from !== 'function') {
                    console.log('Supabase未正确初始化，使用localStorage数据');
                    // 显示Supabase未初始化通知
                    showNotification('Supabase未初始化，当前处于本地存储模式', false);
                    const localData = loadFromLocalStorage() || [];
                    console.log('从localStorage加载的数据:', localData ? localData.length : 0, '个任务');
                    return localData;
                }
                
                // 获取本地存储的数据
                const localData = loadFromLocalStorage() || [];
                console.log('本地数据:', localData.length, '个任务');
                console.log('本地数据样例:', localData.slice(0, 1));
                
                console.log('开始从Supabase请求数据...');
                console.log('请求详情: 表名=tasks_13, 操作=select(*), 方式=GET');
                console.log('请求URL:', supabaseUrl);
                
                let remoteData = null;
                let supabaseError = null;
                
                try {
                    // 单独的try-catch来捕获fetch错误
                    const startTime = Date.now();
                    
                    // 配置请求超时
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                    
                    const result = await supabase
                        .from('tasks_13')
                        .select('*')
                        .abortSignal(controller.signal);
                    
                    clearTimeout(timeoutId);
                    const endTime = Date.now();
                    
                    remoteData = result.data;
                    supabaseError = result.error;
                    
                    console.log('Supabase请求完成，耗时:', (endTime - startTime), 'ms');
                    
                    if (supabaseError) {
                        console.error('从Supabase加载失败:', supabaseError.message);
                        console.error('错误详情:', supabaseError);
                        console.error('错误类型:', supabaseError.code);
                        console.error('错误详情:', supabaseError.details);
                        
                        // 根据错误类型显示不同的通知
                        let errorMessage = '从Supabase加载数据失败，正在尝试使用最新缓存';
                        if (supabaseError.code === 'PGRST301' || supabaseError.code === 'PGRST300') {
                            errorMessage = 'Supabase表不存在或权限不足，使用本地存储数据';
                        } else if (supabaseError.code === '42501') {
                            errorMessage = 'Supabase权限错误，使用本地存储数据';
                        }
                        
                        // 显示加载失败通知
                        showNotification(errorMessage, false);
                        // 如果从Supabase加载失败，尝试从localStorage加载
                        return localData;
                    }
                } catch (fetchError) {
                    // 专门捕获fetch错误
                    console.error('Supabase fetch请求失败:', fetchError);
                    console.error('fetch错误详情:', fetchError);
                    console.error('fetch错误类型:', typeof fetchError);
                    console.error('fetch错误消息:', fetchError.message);
                    console.error('fetch错误堆栈:', fetchError.stack);
                    
                    // 根据错误类型显示不同的通知
                    let errorMessage = '网络请求失败，正在尝试使用最新缓存';
                    if (fetchError.name === 'AbortError') {
                        errorMessage = '请求超时，正在尝试使用最新缓存';
                    } else if (fetchError.name === 'TypeError' && fetchError.message === 'Failed to fetch') {
                        errorMessage = '无法连接到Supabase服务器，请检查网络连接';
                    }
                    
                    // 显示加载失败通知
                    showNotification(errorMessage, false);
                    // 使用本地存储数据作为回退
                    return localData;
                }
                
                console.log('从Supabase获取到的数据:', remoteData ? remoteData.length : 0, '个任务');
                console.log('Supabase返回数据样例:', remoteData ? remoteData.slice(0, 1) : '无');
                
                if (remoteData && remoteData.length > 0) {
                    // 处理云端数据：将 monthly_interval 类型的 startTime 转换为 startTimes 数组
                    const processedRemoteData = remoteData.map(task => {
                        if (task.recurrence && task.recurrence.type === 'monthly_interval') {
                            // 创建副本以避免直接修改原始数据
                            const updatedTask = { ...task };
                            updatedTask.recurrence = { ...updatedTask.recurrence };
                            
                            // 如果存在 startTime 但不存在 startTimes，则转换
                            if (updatedTask.recurrence.startTime && !updatedTask.recurrence.startTimes) {
                                updatedTask.recurrence.startTimes = [updatedTask.recurrence.startTime];
                                delete updatedTask.recurrence.startTime;
                            }
                            return updatedTask;
                        }
                        return task;
                    });
                    
                    // 合并本地和远程数据，基于时间戳
                    console.log('开始合并本地和云端数据...');
                    const mergedData = mergeData(localData, processedRemoteData);
                    
                    // 将合并后的数据保存到localStorage
                    localStorage.setItem('timeProjectReminderTasks', JSON.stringify(mergedData));
                    console.log('合并后的数据已保存到localStorage');
                    
                    // 验证合并结果
                    console.log('合并前后数据对比:');
                    console.log('  本地:', localData.length, '个任务');
                    console.log('  云端:', remoteData.length, '个任务');
                    console.log('  合并后:', mergedData.length, '个任务');
                    
                    // 分析合并结果
                    const addedTasks = mergedData.filter(task => 
                        !localData.some(local => local.id === task.id)
                    );
                    const updatedTasks = mergedData.filter(task => {
                        const localTask = localData.find(local => local.id === task.id);
                        return localTask && new Date(task.updated_at) > new Date(localTask.updated_at);
                    });
                    
                    console.log('合并分析:');
                    console.log('  新增任务:', addedTasks.length, '个');
                    console.log('  更新任务:', updatedTasks.length, '个');
                    
                    // 显示云端数据加载成功通知
                    showNotification('云端数据加载成功', false);
                    return mergedData;
                } else {
                    // 如果Supabase返回空数据，尝试从localStorage加载
                    console.log('Supabase返回空数据，使用localStorage数据');
                    // 显示Supabase返回空数据通知
                    showNotification('Supabase中没有数据，使用本地存储数据', false);
                    // 检查是否需要将本地数据推送到Supabase
                    if (localData.length > 0) {
                        console.log('检测到本地有数据，建议将本地数据推送到Supabase');
                    }
                    return localData;
                }
            } catch (e) {
                console.error('从Supabase加载时发生异常:', e);
                console.error('异常类型:', typeof e);
                console.error('异常堆栈:', e.stack);
                
                // 更详细地分析异常类型
                let errorMessage = '从Supabase加载数据异常，使用本地存储数据';
                if (e.name === 'NetworkError' || (e.name === 'TypeError' && e.message.includes('network'))) {
                    errorMessage = '网络连接异常，当前处于本地存储模式';
                } else if (e.name === 'TimeoutError') {
                    errorMessage = '请求超时，当前处于本地存储模式';
                }
                
                // 显示加载异常通知
                showNotification(errorMessage, true);
                // 如果从Supabase加载失败，尝试从localStorage加载
                const localData = loadFromLocalStorage() || [];
                console.log('从localStorage加载的数据:', localData ? localData.length : 0, '个任务');
                return localData;
            } finally {
                console.log('=== 从Supabase加载数据完成 ===');
            }
        }
        
        // 从localStorage加载数据（作为备用）
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('timeProjectReminderTasks');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    // 过滤异常任务数据：
                    // 1. ID超出PostgreSQL integer范围 (-2,147,483,648 到 2,147,483,647)
                    // 2. 缺少必要字段的任务
                    const validData = parsedData.filter(task => {
                        if (!task || typeof task.id !== 'number') {
                            console.warn('过滤掉异常任务（无效ID或任务对象）:', task);
                            return false;
                        }
                        if (task.id < -2147483648 || task.id > 2147483647) {
                            console.warn('过滤掉ID超出范围的任务 (ID:', task.id, '):', task.name);
                            return false;
                        }
                        return true;
                    });
                    
                    // 如果过滤掉了异常数据，保存过滤后的有效数据回localStorage
                    if (validData.length < parsedData.length) {
                        console.log('已过滤掉', parsedData.length - validData.length, '条异常任务数据');
                        localStorage.setItem('timeProjectReminderTasks', JSON.stringify(validData));
                    }
                    
                    return validData;
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
                showNotification('加载数据失败: ' + e.message, true);
            }
            return null;
        }
        
        // 保存数据到Supabase和localStorage
        async function saveData(data, retry = 0) {
            if (saveState.isSaving) {
                if (retry < saveState.maxAttempts) {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            saveData(data, retry + 1)
                                .then(resolve)
                                .catch(resolve);
                        }, 300);
                    });
                }
                return Promise.resolve(false);
            }
            
            saveState.isSaving = true;
            showSaveStatus(true);
            
            return new Promise(async resolve => {
                try {
                    if (!data || !Array.isArray(data)) {
                        throw new Error('无效的数据格式');
                    }
                    
                    // 为每个任务添加或更新时间戳
                    const now = new Date().toISOString();
                    const dataWithTimestamps = data.map(task => ({
                        ...task,
                        updated_at: now,
                        created_at: task.created_at || now
                    }));
                    
                    // 先保存到localStorage作为备份
                    localStorage.setItem('timeProjectReminderTasks', JSON.stringify(dataWithTimestamps));
                    
                    // 检查supabase是否已初始化
                    if (supabase) {
                        console.log('开始保存数据到Supabase...');
                        console.log('待保存数据:', data.length, '个任务');
                        console.log('待保存数据样例:', data.slice(0, 1));
                        
                        // 然后保存到Supabase
                        // 使用更安全的同步策略：
                        // 1. 先获取当前数据库中的所有任务
                        console.log('步骤1: 获取当前数据库中的所有任务...');
                        let existingTasks = null;
                        let fetchError = null;
                        
                        try {
                            // 创建AbortController来控制请求超时
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                            
                            const result = await supabase
                                .from('tasks_13')
                                .select('id, updated_at')
                                .abortSignal(controller.signal);
                            
                            clearTimeout(timeoutId); // 清除超时定时器
                            existingTasks = result.data;
                            fetchError = result.error;
                            
                            if (fetchError) {
                                console.error('获取现有任务失败:', fetchError.message);
                                throw fetchError;
                            }
                        } catch (e) {
                            console.error('获取现有任务时fetch请求失败:', e);
                            console.error('fetch错误详情:', e);
                            console.error('fetch错误消息:', e.message);
                            console.error('fetch错误堆栈:', e.stack);
                            
                            // 详细的错误类型处理
                            let errorMessage = '网络请求失败，已保存到本地存储';
                            if (e.name === 'AbortError') {
                                errorMessage = '请求超时，已保存到本地存储';
                                console.error('Supabase请求超时');
                            } else if (e.message.includes('Failed to fetch')) {
                                errorMessage = '网络连接失败，已保存到本地存储';
                                console.error('网络连接失败');
                            } else if (e.message.includes('401')) {
                                errorMessage = 'Supabase认证失败，已保存到本地存储';
                                console.error('Supabase认证失败');
                            } else if (e.message.includes('403')) {
                                errorMessage = '权限不足，已保存到本地存储';
                                console.error('Supabase权限不足');
                            } else if (e.message.includes('404')) {
                                errorMessage = '请求资源不存在，已保存到本地存储';
                                console.error('Supabase资源不存在');
                            } else if (e.message.includes('500')) {
                                errorMessage = '服务器错误，已保存到本地存储';
                                console.error('Supabase服务器错误');
                            }
                            
                            // 只记录错误，不中断流程，继续使用本地数据
                            showNotification(errorMessage, false);
                            // 更新状态并返回成功，因为本地存储已经保存
                            saveState.lastSaved = new Date();
                            saveState.saveAttempts = 0;
                            saveState.isSaving = false;
                            showSaveStatus(false, true);
                            resolve(true);
                            return;
                        }
                        
                        console.log('现有任务:', existingTasks ? existingTasks.length : 0, '个任务');
                        
                        // 2. 获取现有任务的id和更新时间列表
                        const existingTasksMap = new Map();
                        if (existingTasks && existingTasks.length > 0) {
                            existingTasks.forEach(task => {
                                existingTasksMap.set(task.id, task.updated_at);
                            });
                        }
                        console.log('现有任务映射表大小:', existingTasksMap.size);
                        
                        // 3. 分离需要插入和更新的任务，基于id和时间戳
                        // 只有真正没有id的任务才应该被插入，已存在id且本地版本更新的任务才应该被更新
                        const tasksToInsert = [];
                        const tasksToUpdate = [];
                        
                        for (const task of dataWithTimestamps) {
                            if (!task.id) {
                                console.log(`任务 ${task.name}: 无ID，准备插入`);
                                tasksToInsert.push(task);
                            } else if (existingTasksMap.has(task.id)) {
                                // 比较时间戳，只有本地版本更新时才更新
                                const serverUpdatedAt = existingTasksMap.get(task.id);
                                if (!serverUpdatedAt || new Date(task.updated_at) > new Date(serverUpdatedAt)) {
                                    console.log(`任务 ${task.id}: 本地版本更新，准备更新`);
                                    tasksToUpdate.push(task);
                                } else {
                                    console.log(`任务 ${task.id}: 服务器版本更新，跳过`);
                                }
                            } else {
                                // 数据库中没有这个id，需要插入
                                console.log(`任务 ${task.id}: 服务器不存在，准备插入`);
                                tasksToInsert.push(task);
                            }
                        }
                        
                        console.log('准备插入:', tasksToInsert.length, '个任务');
                        console.log('准备更新:', tasksToUpdate.length, '个任务');
                        
                        // 4. 执行更新操作
                        if (tasksToUpdate.length > 0) {
                            console.log('步骤4: 执行更新操作...');
                            for (const task of tasksToUpdate) {
                                console.log(`更新任务: ${task.id} - ${task.name}`);
                                let updateError = null;
                                
                                try {
                                    // 创建AbortController来控制请求超时
                                    const controller = new AbortController();
                                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                                    
                                    const result = await supabase
                                        .from('tasks_13')
                                        .update(task)
                                        .eq('id', task.id)
                                        .abortSignal(controller.signal);
                                    
                                    clearTimeout(timeoutId); // 清除超时定时器
                                    updateError = result.error;
                                    
                                    if (updateError) {
                                        console.error(`更新任务 ${task.id} 失败:`, updateError.message);
                                        throw updateError;
                                    }
                                } catch (e) {
                                    // 详细的错误类型处理
                                    let errorMessage = '部分任务更新失败，已保存到本地存储';
                                    if (e.name === 'AbortError') {
                                        errorMessage = '更新请求超时，已保存到本地存储';
                                        console.error(`更新任务 ${task.id} 请求超时:`, e);
                                    } else if (e.message.includes('Failed to fetch')) {
                                        errorMessage = '网络连接失败，已保存到本地存储';
                                        console.error(`更新任务 ${task.id} 网络连接失败:`, e);
                                    } else {
                                        console.error(`更新任务 ${task.id} 失败:`, e);
                                        console.error('错误详情:', e);
                                        console.error('错误消息:', e.message);
                                        console.error('错误堆栈:', e.stack);
                                    }
                                    
                                    // 只记录错误，不中断流程，继续使用本地数据
                                    showNotification(errorMessage, false);
                                    // 更新状态并返回成功，因为本地存储已经保存
                                    saveState.lastSaved = new Date();
                                    saveState.saveAttempts = 0;
                                    saveState.isSaving = false;
                                    showSaveStatus(false, true);
                                    resolve(true);
                                    return;
                                }
                            }
                            console.log('更新操作完成');
                        }
                        
                        // 5. 执行插入操作
                        if (tasksToInsert.length > 0) {
                            console.log('步骤5: 执行插入操作...');
                            let insertedData = null;
                            let insertError = null;
                            
                            try {
                                // 创建AbortController来控制请求超时
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                                
                                const result = await supabase
                                    .from('tasks_13')
                                    .insert(tasksToInsert)
                                    .select()
                                    .abortSignal(controller.signal);
                                
                                clearTimeout(timeoutId); // 清除超时定时器
                                insertedData = result.data;
                                insertError = result.error;
                                
                                if (insertError) {
                                    console.error('插入任务失败:', insertError.message);
                                    throw insertError;
                                }
                            } catch (e) {
                                console.error('插入任务时fetch请求失败:', e);
                                console.error('fetch错误详情:', e);
                                console.error('fetch错误消息:', e.message);
                                console.error('fetch错误堆栈:', e.stack);
                                
                                // 详细的错误类型处理
                                let errorMessage = '部分任务插入失败，已保存到本地存储';
                                if (e.name === 'AbortError') {
                                    errorMessage = '插入请求超时，已保存到本地存储';
                                    console.error('插入请求超时');
                                } else if (e.message.includes('Failed to fetch')) {
                                    errorMessage = '网络连接失败，已保存到本地存储';
                                    console.error('网络连接失败');
                                }
                                
                                // 只记录错误，不中断流程，继续使用本地数据
                                showNotification(errorMessage, false);
                                // 更新状态并返回成功，因为本地存储已经保存
                                saveState.lastSaved = new Date();
                                saveState.saveAttempts = 0;
                                saveState.isSaving = false;
                                showSaveStatus(false, true);
                                resolve(true);
                                return;
                            }
                            
                            console.log('插入操作完成，成功插入:', insertedData ? insertedData.length : 0, '个任务');
                            
                            // 更新本地任务对象，添加Supabase自动生成的ID
                            if (insertedData && insertedData.length > 0) {
                                insertedData.forEach((insertedTask, index) => {
                                    // 找到对应的本地任务并更新ID
                                    const localTaskIndex = dataWithTimestamps.findIndex(t => 
                                        !t.id && 
                                        t.name === insertedTask.name && 
                                        t.startDate === insertedTask.startDate &&
                                        t.startTime === insertedTask.startTime &&
                                        t.updated_at === insertedTask.updated_at
                                    );
                                    if (localTaskIndex !== -1) {
                                        dataWithTimestamps[localTaskIndex].id = insertedTask.id;
                                        data[localTaskIndex].id = insertedTask.id;
                                        data[localTaskIndex].created_at = insertedTask.created_at;
                                        data[localTaskIndex].updated_at = insertedTask.updated_at;
                                        console.log(`任务 ${insertedTask.name}: 已分配ID ${insertedTask.id}`);
                                    }
                                });
                                
                                // 将更新后的ID保存到localStorage
                                localStorage.setItem('timeProjectReminderTasks', JSON.stringify(dataWithTimestamps));
                                console.log('已将更新后的ID保存到localStorage');
                            }
                        }
                        
                        console.log('数据保存到Supabase完成');
                    } else {
                        console.log('Supabase未初始化，仅保存到localStorage');
                    }
                    
                    saveState.lastSaved = new Date();
                    saveState.saveAttempts = 0;
                    saveState.isSaving = false;
                    
                    showSaveStatus(false, true);
                    showNotification('数据已成功保存');
                    resolve(true);
                } catch (e) {
                    console.error('Failed to save data:', e);
                    
                    saveState.saveAttempts++;
                    saveState.isSaving = false;
                    
                    showSaveStatus(false, false);
                    showNotification('保存失败: ' + e.message, true);
                    
                    if (saveState.saveAttempts >= saveState.maxAttempts) {
                        if (confirm('多次保存失败，是否导出数据以防止丢失？')) {
                            downloadAsHtml();
                        }
                    }
                    
                    resolve(false);
                }
            });
        }

        // 显示保存状态指示器
        function showSaveStatus(isSaving, success = false) {
            const statusEl = document.getElementById('save-status');
            const statusTextEl = document.getElementById('save-status-text');
            
            if (isSaving) {
                statusTextEl.textContent = '保存中...';
                statusEl.classList.remove('hidden', 'text-green-500', 'text-red-500');
                statusEl.classList.add('text-primary');
            } else {
                if (success) {
                    statusTextEl.textContent = '保存成功';
                    statusEl.classList.remove('hidden', 'text-primary', 'text-red-500');
                    statusEl.classList.add('text-green-500');
                    
                    setTimeout(() => {
                        statusEl.classList.add('hidden');
                    }, 2000);
                } else {
                    statusTextEl.textContent = '保存失败';
                    statusEl.classList.remove('hidden', 'text-primary', 'text-green-500');
                    statusEl.classList.add('text-red-500');
                }
            }
        }

        // 显示通知
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            
            if (isError) {
                notification.classList.add('error');
            } else {
                notification.classList.remove('error');
            }
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // 大蜡图片显示功能
        function showLargeWaxImages(imageList, locationName, folderName) {
            // 检查图片列表是否为空，如果为空则不显示图片查看功能
            if (!imageList || imageList.length === 0) {
                showNotification(`今日大蜡位置: ${locationName}`);
                return;
            }
            
            // GitHub Pages 配置
            const githubRepo = 'sky-event/sky-event.github.io';
            const githubImageBaseUrl = `https://raw.githubusercontent.com/${githubRepo}/163/images/${folderName}`;
            
            // 加载图片函数 - 支持本地缓存图片、本地文件和云端图片
            const loadImage = (imageName, imgElement) => {
                // 检查是否为本地缓存图片
                if (imageName.startsWith('local_')) {
                    // 从localStorage加载图片
                    const imageData = localStorage.getItem(`sky_local_image_${imageName}`);
                    if (imageData) {
                        imgElement.src = imageData;
                        imgElement.alt = `本地图片${currentIndex + 1}`;
                        imgElement.onerror = function() {
                            console.log(`本地缓存图片加载失败: ${imageName}`);
                            this.src = './icons/dl.png';
                            this.alt = '图片加载失败';
                        };
                    } else {
                        // 如果localStorage中没有，显示默认图片
                        imgElement.src = './icons/dl.png';
                        imgElement.alt = '图片加载失败';
                    }
                    return;
                }
                
                // 常规图片加载逻辑
                const githubUrl = `${githubImageBaseUrl}/${imageName}`;
                const localUrl = `./images/${folderName}/${imageName}`;
                
                // 1. 先显示本地图片，让用户立即看到内容
                imgElement.src = localUrl;
                imgElement.alt = `大蜡位置${currentIndex + 1}`;
                
                // 2. 本地图片加载失败时的处理
                imgElement.onerror = function() {
                    console.log(`本地图片加载失败，显示默认图片: ${localUrl}`);
                    this.src = './icons/dl.png';
                    this.alt = '图片加载失败';
                };
                
                // 3. 异步加载云端图片（预加载）
                const cloudImg = new Image();
                cloudImg.onload = function() {
                    // 云端图片加载成功，替换本地图片
                    console.log(`云端图片加载成功，替换本地图片: ${githubUrl}`);
                    imgElement.src = githubUrl;
                    imgElement.alt = `大蜡位置${currentIndex + 1}`;
                };
                cloudImg.onerror = function() {
                    // 云端图片加载失败，保持显示本地图片
                    console.log(`云端图片加载失败，保持显示本地图片: ${githubUrl}`);
                };
                cloudImg.src = githubUrl;
            };
            
            // 创建图片模态框
            let modalHTML = `
                <div id="large-wax-modal" class="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4" style="opacity: 0; transition: opacity 0.3s ease-in;">
                    <!-- 标题 - 固定在屏幕上方并添加背景标签 -->
                    <div class="fixed top-4 left-0 right-0 text-center z-20">
                        <div id="large-wax-title" class="text-white bg-black bg-opacity-70 px-3 py-1 rounded-full shadow-lg inline-block font-bold cursor-pointer" title="双击添加本地图片">${locationName}</div>
                    </div>
                    
                    <div class="relative" style="transform: scale(0.9); transition: transform 0.3s ease-in;">
                        <!-- 图片容器 - 自适应图片大小 -->
                        <div id="large-wax-image-container" class="relative overflow-hidden shadow-2xl inline-block" style="touch-action: manipulation; cursor: grab; border-radius: 24px;">
                            <img id="large-wax-image" src="" 
                                 alt="大蜡位置" 
                                 class="w-auto h-auto max-w-[90vw] max-h-[90vh] object-contain transition-all duration-300" 
                                 style="opacity: 0; transition: opacity 0.3s ease-in 0.1s;" />
                        </div>
                    </div>
                    
                    <!-- 左右翻页按钮 - 根据图片数量和当前位置显示 -->
                    ${imageList.length > 1 ? `
                        <button id="large-wax-prev" class="fixed left-4 top-1/2 transform -translate-y-1/2 text-white bg-black bg-opacity-70 hover:bg-opacity-90 p-2 sm:p-3 rounded-full shadow-lg z-20 transition-all opacity-0 invisible" style="transition: opacity 0.3s ease-in;">
                            <i class="fa fa-chevron-left text-2xl sm:text-3xl font-bold"></i>
                        </button>
                        <button id="large-wax-next" class="fixed right-4 top-1/2 transform -translate-y-1/2 text-white bg-black bg-opacity-70 hover:bg-opacity-90 p-2 sm:p-3 rounded-full shadow-lg z-20 transition-all opacity-100 visible" style="transition: opacity 0.3s ease-in;">
                            <i class="fa fa-chevron-right text-2xl sm:text-3xl font-bold"></i>
                        </button>
                    ` : ''}
                    
                    <!-- 分页信息 - 固定在屏幕下方 -->
                    <div id="large-wax-pagination" class="fixed bottom-4 left-0 right-0 text-white bg-black bg-opacity-70 px-2 py-0.5 text-sm rounded-full shadow-lg mx-auto max-w-fit z-20">
                        ${imageList.length > 1 ? `1/${imageList.length}` : ''}
                    </div>
                </div>
            `;
            
            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // 初始化图片索引
            let currentIndex = 0;
            
            // 获取DOM元素
            const modal = document.getElementById('large-wax-modal');
            const largeImage = document.getElementById('large-wax-image');
            const pagination = document.getElementById('large-wax-pagination');
            const imageContainer = document.getElementById('large-wax-image-container');
            const modalContent = modal.querySelector('.relative');
            const prevButton = document.getElementById('large-wax-prev');
            const nextButton = document.getElementById('large-wax-next');
            const titleElement = document.getElementById('large-wax-title');
            
            // 添加双击标题添加本地图片功能
            titleElement.addEventListener('dblclick', () => {
                // 创建文件输入元素
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.multiple = true;
                fileInput.style.display = 'none';
                
                // 添加到DOM
                document.body.appendChild(fileInput);
                
                // 监听文件选择
                fileInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files);
                    if (files.length === 0) return;
                    
                    // 处理每个选中的文件
                    files.forEach(file => {
                        if (!file.type.startsWith('image/')) return;
                        
                        const reader = new FileReader();
                        reader.onload = (readerEvent) => {
                            // 生成唯一文件名
                            const timestamp = Date.now();
                            const fileName = `local_${timestamp}.${file.name.split('.').pop()}`;
                            
                            // 存储到localStorage
                            localStorage.setItem(`sky_local_image_${fileName}`, readerEvent.target.result);
                            
                            // 添加到图片列表
                            imageList.push(fileName);
                            
                            // 更新分页
                            if (pagination) {
                                pagination.textContent = `${currentIndex + 1}/${imageList.length}`;
                            }
                            
                            // 显示添加成功通知
                            showNotification(`已添加本地图片: ${file.name}`);
                        };
                        reader.readAsDataURL(file);
                    });
                    
                    // 移除文件输入元素
                    document.body.removeChild(fileInput);
                });
                
                // 触发文件选择
                fileInput.click();
            });
            
            // 加载第一张图片
            loadImage(imageList[0], largeImage);
            
            // 添加显示动画
            // 触发重排
            void modal.offsetWidth;
            
            // 设置最终状态
            modal.style.opacity = '1';
            modalContent.style.transform = 'scale(1)';
            largeImage.style.opacity = '1';
            
            // 响应式设计：手机端调整初始大小
            if (window.innerWidth <= 640) {
                // 手机端：将图片容器初始大小调整为中间值
                largeImage.style.maxWidth = '85vw';
                largeImage.style.maxHeight = '80vh';
            } else {
                // 桌面端：保持原有大小
                largeImage.style.maxWidth = '90vw';
                largeImage.style.maxHeight = '90vh';
            }
            
            // 初始化按钮状态
            changeImage(currentIndex);
            
            // 缩放和拖动功能
            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            let lastDistance = 0;
            let isPinching = false;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let initialTranslateX = 0;
            let initialTranslateY = 0;
            
            // 计算边缘限制
            function calculateEdgeLimits() {
                // 获取容器的原始尺寸（不考虑缩放）
                const originalWidth = imageContainer.offsetWidth;
                const originalHeight = imageContainer.offsetHeight;
                
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const edgeMargin = 40; // 固定边距值，不随缩放变化
                
                // 计算缩放后的容器尺寸
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;
                
                // 计算最大拖动范围
                let maxTranslateX = 0;
                let maxTranslateY = 0;
                
                // 计算X轴最大拖动距离
                if (scaledWidth > viewportWidth - 2 * edgeMargin) {
                    // 计算图片需要显示的区域（考虑边距）
                    const displayWidth = viewportWidth - 2 * edgeMargin;
                    // 图片超出显示区域的部分
                    const overflowX = scaledWidth - displayWidth;
                    // 最大拖动距离是超出部分的一半，不除以scale以允许在放大后自由拖动
                    maxTranslateX = (overflowX / 2);
                }
                
                // 计算Y轴最大拖动距离
                if (scaledHeight > viewportHeight - 2 * edgeMargin) {
                    // 计算图片需要显示的区域（考虑边距）
                    const displayHeight = viewportHeight - 2 * edgeMargin;
                    // 图片超出显示区域的部分
                    const overflowY = scaledHeight - displayHeight;
                    // 最大拖动距离是超出部分的一半，不除以scale以允许在放大后自由拖动
                    maxTranslateY = (overflowY / 2);
                }
                
                return { maxTranslateX, maxTranslateY };
            }
            
            // 应用边缘限制
            function applyEdgeLimits(newTranslateX, newTranslateY) {
                // 无论图片是否放大，都应用边缘限制，确保图片不会完全拖出视野
                const { maxTranslateX, maxTranslateY } = calculateEdgeLimits();
                
                // 限制拖动范围，确保图片边缘与屏幕边缘保持边距
                const limitedX = Math.max(-maxTranslateX, Math.min(maxTranslateX, newTranslateX));
                const limitedY = Math.max(-maxTranslateY, Math.min(maxTranslateY, newTranslateY));
                
                return { x: limitedX, y: limitedY };
            }
            
            // 更新变换 - 将缩放应用到容器而不是图片
            function updateTransform() {
                imageContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }
            
            // 关闭模态框 - 添加淡出过渡效果
            function closeModal() {
                modal.style.opacity = '0';
                modalContent.style.transform = 'scale(0.9)';
                largeImage.style.opacity = '0';
                
                // 等待动画完成后再移除元素
                setTimeout(() => {
                    modal.remove();
                }, 300);
            }
            
            // 切换图片 - 添加淡入淡出过渡效果
            function changeImage(newIndex) {
                if (newIndex >= 0 && newIndex < imageList.length) {
                    // 添加淡出效果
                    largeImage.style.opacity = '0';
                    largeImage.style.transition = 'opacity 0.3s ease-out';
                    
                    // 使用setTimeout确保淡出动画完成后再加载新图片
                    setTimeout(() => {
                        currentIndex = newIndex;
                        
                        // 使用loadImage函数加载图片
                        loadImage(imageList[currentIndex], largeImage);
                        
                        // 预加载下一张图片
                        if (imageList.length > 1) {
                            const nextIndex = (currentIndex + 1) % imageList.length;
                            const preloadImg = new Image();
                            const nextImageName = imageList[nextIndex];
                            
                            if (!nextImageName.startsWith('local_')) {
                                // 常规图片预加载
                                const githubUrl = `${githubImageBaseUrl}/${nextImageName}`;
                                const localUrl = `./images/${folderName}/${nextImageName}`;
                                
                                // 先预加载本地图片
                                preloadImg.src = localUrl;
                                preloadImg.onerror = () => {
                                    // 本地图片加载失败，预加载云端图片
                                    preloadImg.src = githubUrl;
                                };
                            }
                        }
                        
                        // 图片加载完成后添加淡入效果
                        largeImage.onload = () => {
                            largeImage.style.transition = 'opacity 0.3s ease-in';
                            largeImage.style.opacity = '1';
                            
                            // 图片加载完成后应用边缘限制
                            const { x: limitedX, y: limitedY } = applyEdgeLimits(translateX, translateY);
                            translateX = limitedX;
                            translateY = limitedY;
                            updateTransform();
                        };
                        
                        if (pagination) {
                            // 确保显示正确的图片数量
                            pagination.textContent = `${currentIndex + 1}/${imageList.length}`;
                        }
                        
                        // 更新左右翻页按钮的显示状态
                        if (prevButton) {
                            if (currentIndex > 0) {
                                prevButton.classList.remove('opacity-0', 'invisible');
                                prevButton.classList.add('opacity-100', 'visible');
                            } else {
                                prevButton.classList.remove('opacity-100', 'visible');
                                prevButton.classList.add('opacity-0', 'invisible');
                            }
                        }
                        
                        if (nextButton) {
                            if (currentIndex < imageList.length - 1) {
                                nextButton.classList.remove('opacity-0', 'invisible');
                                nextButton.classList.add('opacity-100', 'visible');
                            } else {
                                nextButton.classList.remove('opacity-100', 'visible');
                                nextButton.classList.add('opacity-0', 'invisible');
                            }
                        }
                    }, 300);
                }
            }
            
            // 触摸开始事件
            imageContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // 双指缩放
                    isPinching = true;
                    lastDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                } else if (e.touches.length === 1) {
                    // 单指触摸（拖动或滑动）
                    // 记录起始位置，无论是否缩放
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    initialTranslateX = translateX;
                    initialTranslateY = translateY;
                    
                    // 如果已经缩放，允许拖动
                    if (scale > 1) {
                        isDragging = true;
                    }
                }
            });
            
            // 触摸移动事件
            imageContainer.addEventListener('touchmove', (e) => {
                e.preventDefault(); // 阻止默认行为，提高响应速度
                if (isPinching && e.touches.length === 2) {
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    const delta = currentDistance - lastDistance;
                    const newScale = scale + delta * 0.005; // 增大缩放系数，提高缩放灵敏度
                    
                    // 限制缩放范围在1-5之间
                    const limitedScale = Math.max(1, Math.min(5, newScale));
                    
                    // 使用requestAnimationFrame优化性能，减少抖动
                    requestAnimationFrame(() => {
                        // 更新缩放
                        scale = limitedScale;
                        
                        // 如果缩小到原始尺寸，将图片重置到中心位置
                        if (scale === 1) {
                            translateX = 0;
                            translateY = 0;
                        } else {
                            // 缩放时也应用边缘限制
                            const { x: limitedX, y: limitedY } = applyEdgeLimits(translateX, translateY);
                            translateX = limitedX;
                            translateY = limitedY;
                        }
                        
                        updateTransform();
                    });
                    
                    lastDistance = currentDistance;
                } else if (e.touches.length === 1) {
                    // 单指移动
                    if (scale > 1 && isDragging) {
                        e.preventDefault();
                        const currentX = e.touches[0].clientX;
                        const currentY = e.touches[0].clientY;
                        
                        // 计算新的位置，直接使用拖动距离，实现跟手移动
                        let dragX = currentX - startX;
                        let dragY = currentY - startY;
                        let newTranslateX = initialTranslateX + dragX;
                        let newTranslateY = initialTranslateY + dragY;
                        
                        // 应用边缘限制
                        const { x: limitedX, y: limitedY } = applyEdgeLimits(newTranslateX, newTranslateY);
                        
                        // 使用requestAnimationFrame优化性能
                        requestAnimationFrame(() => {
                            // 更新位置
                            translateX = limitedX;
                            translateY = limitedY;
                            updateTransform();
                        });
                    }
                    // 不阻止默认行为，以便在非缩放状态下可以滑动切换图片
                }
            });
            
            // 触摸结束事件
            imageContainer.addEventListener('touchend', (e) => {
                // 检查是否是单指触摸结束
                if (e.changedTouches.length === 1) {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    
                    // 计算滑动距离
                    const deltaX = endX - startX;
                    const deltaY = endY - startY;
                    
                    // 判断是否是左右滑动手势（水平滑动距离大于垂直滑动距离，且滑动距离足够大）
                    if (Math.abs(deltaX) > Math.abs(deltaY) * 2 && Math.abs(deltaX) > 30) {
                        // 只有在原始缩放比例（未缩放）时才允许滑动切换图片
                        if (scale === 1) {
                            if (deltaX > 0) {
                                // 向右滑动，查看上一张图片
                                changeImage(currentIndex - 1);
                            } else {
                                // 向左滑动，查看下一张图片
                                changeImage(currentIndex + 1);
                            }
                        }
                    }
                }
                
                // 重置触摸状态
                isPinching = false;
                isDragging = false;
                lastDistance = 0;
            });
            
            // 鼠标按下事件（拖动开始）
            imageContainer.addEventListener('mousedown', (e) => {
                if (scale > 1) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialTranslateX = translateX;
                    initialTranslateY = translateY;
                    imageContainer.style.cursor = 'grabbing';
                    e.preventDefault(); // 防止默认行为
                }
            });
            
            // 鼠标移动事件（拖动中）
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault(); // 防止页面滚动和选择文本
                    
                    const currentX = e.clientX;
                    const currentY = e.clientY;
                    
                    // 计算新的位置，移除除以scale的操作以提高放大后拖动的灵敏度
                    let dragX = currentX - startX;
                    let dragY = currentY - startY;
                    let newTranslateX = initialTranslateX + dragX;
                    let newTranslateY = initialTranslateY + dragY;
                    
                    // 应用边缘限制
                    const { x: limitedX, y: limitedY } = applyEdgeLimits(newTranslateX, newTranslateY);
                    
                    // 更新位置
                    translateX = limitedX;
                    translateY = limitedY;
                    
                    // 使用requestAnimationFrame提高性能
                    requestAnimationFrame(() => {
                        updateTransform();
                    });
                }
            });
            
            // 鼠标释放事件（拖动结束）
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    imageContainer.style.cursor = 'grab';
                }
            });
            
            // 双击重置缩放和位置
            imageContainer.addEventListener('dblclick', () => {
                // 添加缩放动画
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
            });
            
            // 鼠标滚轮缩放
            imageContainer.addEventListener('wheel', (e) => {
                e.preventDefault(); // 防止页面滚动
                
                // 计算新的缩放比例
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(1, Math.min(5, scale * scaleFactor));
                
                // 计算图片中心
                const imageCenterX = largeImage.width / 2;
                const imageCenterY = largeImage.height / 2;
                const containerRect = imageContainer.getBoundingClientRect();
                const containerCenterX = containerRect.width / 2;
                const containerCenterY = containerRect.height / 2;
                
                // 计算新的translate值，保持图片中心与容器中心对齐
                const newTranslateX = containerCenterX - imageCenterX * newScale;
                const newTranslateY = containerCenterY - imageCenterY * newScale;
                
                // 更新缩放和平移
                scale = newScale;
                translateX = newTranslateX;
                translateY = newTranslateY;
                
                // 应用边缘限制
                const { x: limitedX, y: limitedY } = applyEdgeLimits(translateX, translateY);
                translateX = limitedX;
                translateY = limitedY;
                
                // 更新变换
                updateTransform();
            });
            
            // 键盘导航
            document.addEventListener('keydown', function handleKeydown(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', handleKeydown);
                } else if (e.key === 'ArrowLeft' && imageList.length > 1) {
                    changeImage(currentIndex - 1);
                } else if (e.key === 'ArrowRight' && imageList.length > 1) {
                    changeImage(currentIndex + 1);
                }
            });
            
            // 点击模态框背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // 点击图片容器不关闭
            imageContainer.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // 左右按钮点击事件
            if (prevButton) {
                prevButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    changeImage(currentIndex - 1);
                });
            }
            
            if (nextButton) {
                nextButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    changeImage(currentIndex + 1);
                });
            }
        }

        // 计算事件的下一次发生时间 - 基于太平洋时间计算
        function getNextOccurrence(task, nowCST) {
            try {
                // 破晓红石特殊处理
                if (task.recurrence.type === "custom_complex" && task.recurrence.pattern === "dawn_redstone") {
                    return getNextDawnRedstoneOccurrence(nowCST);
                }
                
                // 圆梦滑冰特殊处理
                if (task.recurrence.type === "custom_complex" && task.recurrence.pattern === "dream_skating") {
                    return DreamSkatingRules.getNextOccurrence(nowCST);
                }
                
                // 获取开始时间（太平洋时间）
                let startTimeStr = task.startTime;
                // 对于daily、weekly和monthly类型的任务，使用recurrence.startTimes中的第一个时间
                if (!startTimeStr && task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                    startTimeStr = task.recurrence.startTimes[0];
                }
                // 对于monthly类型的任务，使用recurrence.startTime（兼容旧格式）
                if (!startTimeStr && task.recurrence.startTime) {
                    startTimeStr = task.recurrence.startTime;
                }
                // 默认时间为00:00
                startTimeStr = startTimeStr || "00:00";
                
                let startHour, startMinute;
                
                // 确保startTimeStr是字符串
                if (startTimeStr instanceof Date) {
                    // 如果是Date对象，先转换为PDT时间，然后再提取小时和分钟
                    const pdtDate = TimeZoneUtils.CSTtoPDT(startTimeStr);
                    startHour = pdtDate.getHours();
                    startMinute = pdtDate.getMinutes();
                } else {
                    // 如果是字符串，直接解析
                    const [h, m] = startTimeStr.split(':').map(Number);
                    startHour = h;
                    startMinute = m;
                }
                
                // 获取开始日期
                let startDateStr = task.startDate;
                // 默认日期为当前日期
                startDateStr = startDateStr || new Date().toISOString().split('T')[0];
                const [startYear, startMonth, startDay] = startDateStr.split('-').map(Number);
                
                // 创建nowPDT变量表示当前太平洋时间
                const nowPDT = TimeZoneUtils.CSTtoPDT(nowCST);
                
                // 创建nextTimePDT对象，使用正确的PDT时间
                let nextTimePDT = new Date(nowPDT);
                nextTimePDT.setHours(startHour, startMinute, 0, 0);
                
                // 创建initialStartPDT对象，使用正确的PDT时间
                const initialStartPDT = new Date(startYear, startMonth - 1, startDay, startHour, startMinute, 0, 0);
                
                if (task.recurrence.type === "none") {
                    // 不重复事件，直接返回开始时间
                    return {
                        startTime: TimeZoneUtils.PDTtoCST(initialStartPDT),
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "daily") {
                    // 每天重复
                    let timePoints = [];
                    
                    // 检查是时间点模式还是时间段模式
                    if (task.recurrence.rangeStart && task.recurrence.rangeEnd) {
                        // 时间段模式：根据rangeStart、rangeEnd、intervalCount和intervalUnit生成时间点
                        const [startHour, startMinute] = task.recurrence.rangeStart.split(':').map(Number);
                        const [endHour, endMinute] = task.recurrence.rangeEnd.split(':').map(Number);
                        const intervalCount = parseInt(task.recurrence.intervalCount) || 1;
                        const intervalUnit = task.recurrence.intervalUnit || 'hour';
                        
                        // 计算间隔毫秒数
                        const intervalMs = convertToMilliseconds(intervalCount, intervalUnit);
                        
                        // 创建开始和结束时间的Date对象
                        const startDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), nowPDT.getDate(), startHour, startMinute, 0, 0);
                        const endDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), nowPDT.getDate(), endHour, endMinute, 0, 0);
                        
                        // 生成时间段内所有的时间点
                        let currentTimePDT = new Date(startDatePDT);
                        while (currentTimePDT <= endDatePDT) {
                            timePoints.push({
                                hour: currentTimePDT.getHours(),
                                minute: currentTimePDT.getMinutes()
                            });
                            currentTimePDT.setTime(currentTimePDT.getTime() + intervalMs);
                        }
                    } else {
                        // 时间点模式：使用startTimes数组或默认时间点
                        timePoints = task.recurrence.startTimes && task.recurrence.startTimes.length > 0 ? 
                            task.recurrence.startTimes.map(timeStr => {
                                const [h, m] = timeStr.split(':').map(Number);
                                return { hour: h, minute: m };
                            }) : [{ hour: startHour, minute: startMinute }];
                    }
                    
                    // 获取开始日期，确保不早于设置的startDate
                    const startDateStr = task.startDate || new Date().toISOString().split('T')[0];
                    const [startYear, startMonth, startDay] = startDateStr.split('-').map(Number);
                    const initialStartPDT = new Date(startYear, startMonth - 1, startDay, 0, 0, 0, 0);
                    
                    // 计算今天、明天和未来几天的所有时间点组合，直到找到符合条件的时间点
                    const candidates = [];
                    const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                    
                    // 最多检查30天，确保能找到符合条件的时间点
                    for (let dayOffset = 0; dayOffset < 30; dayOffset++) {
                        const checkDatePDT = new Date(nowPDT);
                        checkDatePDT.setDate(checkDatePDT.getDate() + dayOffset);
                        
                        // 确保检查日期不早于startDate
                        if (checkDatePDT < initialStartPDT) {
                            continue;
                        }
                        
                        // 检查当天的所有时间点
                        for (const { hour, minute } of timePoints) {
                            const testDatePDT = new Date(checkDatePDT);
                            testDatePDT.setHours(hour, minute, 0, 0);
                            
                            // 如果时间点在当前时间之后，且不早于startDate，添加到候选列表
                            if (testDatePDT > nowPDT && testDatePDT >= initialStartPDT) {
                                candidates.push(testDatePDT);
                            }
                        }
                        
                        // 如果找到候选时间点，就停止检查
                        if (candidates.length > 0) {
                            break;
                        }
                    }
                    
                    // 如果没有找到合适的时间点（这种情况理论上不会发生，因为我们检查了30天），使用默认逻辑
                    if (candidates.length === 0) {
                        const today = new Date(nowPDT);
                        const tomorrow = new Date(today);
                        tomorrow.setDate(tomorrow.getDate() + 1);
                        
                        // 检查今天的所有时间点
                        for (const { hour, minute } of timePoints) {
                            const testDatePDT = new Date(today);
                            testDatePDT.setHours(hour, minute, 0, 0);
                            if (testDatePDT > nowPDT && testDatePDT >= initialStartPDT) {
                                candidates.push(testDatePDT);
                            }
                        }
                        
                        // 如果今天没有找到合适的时间点，检查明天的所有时间点
                        if (candidates.length === 0) {
                            for (const { hour, minute } of timePoints) {
                                const testDatePDT = new Date(tomorrow);
                                testDatePDT.setHours(hour, minute, 0, 0);
                                if (testDatePDT >= initialStartPDT) {
                                    candidates.push(testDatePDT);
                                }
                            }
                        }
                    }
                    
                    // 选择最近的时间点
                    candidates.sort((a, b) => a - b);
                    
                    // 检查是否正在进行中（需要检查所有时间点，包括今天已经发生过的时间点）
                    const today = new Date(nowPDT);
                    
                    // 首先检查今天的所有时间点（包括已经发生过的），看是否有正在进行中的事件
                    for (const { hour, minute } of timePoints) {
                        const testDatePDT = new Date(today);
                        testDatePDT.setHours(hour, minute, 0, 0);
                        
                        // 确保正在进行中的事件也不早于startDate
                        if (testDatePDT >= initialStartPDT) {
                            const candidateCST = TimeZoneUtils.PDTtoCST(testDatePDT);
                            if (candidateCST <= nowCST && nowCST < candidateCST.getTime() + durationMs) {
                                return {
                                    startTime: candidateCST,
                                    location: ""
                                };
                            }
                        }
                    }
                    
                    // 如果没有正在进行中的事件，返回最近的时间点
                    const nextTimeCST = TimeZoneUtils.PDTtoCST(candidates[0]);
                    return {
                        startTime: nextTimeCST,
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "weekly") {
                    // 每周重复
                    const todayWeekday = nowPDT.getDay();
                    
                    // 获取所有时间点，如果没有则使用当前的startHour和startMinute
                    const timePoints = (task.recurrence.weeklyRepeatType === "time-points" && task.recurrence.startTimes && task.recurrence.startTimes.length > 0) ? 
                        task.recurrence.startTimes.map(timeStr => {
                            const [h, m] = timeStr.split(':').map(Number);
                            return { hour: h, minute: m };
                        }) : [{ hour: startHour, minute: startMinute }];
                    
                    // 首先检查当前是否是time-range模式且有间隔设置
                    if (task.recurrence.weeklyRepeatType === "time-range" && task.recurrence.rangeStart && task.recurrence.rangeEnd && task.recurrence.intervalCount && task.recurrence.intervalUnit) {
                        // 解析时间段
                        const [rangeStartHour, rangeStartMinute] = task.recurrence.rangeStart.split(':').map(Number);
                        const [rangeEndHour, rangeEndMinute] = task.recurrence.rangeEnd.split(':').map(Number);
                        
                        // 转换为分钟数
                        const rangeStartMinutes = rangeStartHour * 60 + rangeStartMinute;
                        const rangeEndMinutes = rangeEndHour * 60 + rangeEndMinute;
                        const rangeDurationMinutes = rangeEndMinutes >= rangeStartMinutes ? rangeEndMinutes - rangeStartMinutes : 1440 + rangeEndMinutes - rangeStartMinutes;
                        
                        // 计算间隔毫秒数
                        const intervalMs = convertToMilliseconds(task.recurrence.intervalCount, task.recurrence.intervalUnit);
                        
                        // 计算事件持续时间
                        const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                        
                        // 查找符合条件的星期几
                        const candidates = [];
                        
                        // 检查未来30天内的所有符合条件的星期几，而不是7天，确保能找到在startDate之后的日期
                        for (let i = 0; i < 30; i++) {
                            const checkDay = (todayWeekday + i) % 7;
                            if (task.recurrence.weekdays.includes(checkDay)) {
                                // 创建当天的rangeStart时间对象（PDT）
                                const dayRangeStartPDT = new Date(nowPDT);
                                dayRangeStartPDT.setDate(dayRangeStartPDT.getDate() + i);
                                dayRangeStartPDT.setHours(rangeStartHour, rangeStartMinute, 0, 0);
                                
                                // 创建当天的rangeEnd时间对象（PDT）
                                const dayRangeEndPDT = new Date(nowPDT);
                                dayRangeEndPDT.setDate(dayRangeEndPDT.getDate() + i);
                                dayRangeEndPDT.setHours(rangeEndHour, rangeEndMinute, 0, 0);
                                
                                // 如果rangeEnd在rangeStart之前，则认为是第二天
                                if (dayRangeEndPDT < dayRangeStartPDT) {
                                    dayRangeEndPDT.setDate(dayRangeEndPDT.getDate() + 1);
                                }
                                
                                // 检查是否在startDate之后
                                if (dayRangeStartPDT < initialStartPDT) {
                                    continue; // 跳过在startDate之前的日期
                                }
                                
                                // 转换为CST时间进行比较
                                const dayRangeStartCST = TimeZoneUtils.PDTtoCST(dayRangeStartPDT);
                                const dayRangeEndCST = TimeZoneUtils.PDTtoCST(dayRangeEndPDT);
                                
                                // 计算当前应该处于哪个间隔的事件
                                const timeSinceRangeStart = nowCST >= dayRangeStartCST ? nowCST - dayRangeStartCST : 0;
                                const currentInterval = Math.floor(timeSinceRangeStart / intervalMs);
                                
                                // 计算当前间隔事件的开始时间
                                let currentEventStartCST = new Date(dayRangeStartCST.getTime() + currentInterval * intervalMs);
                                let currentEventEndCST = new Date(currentEventStartCST.getTime() + durationMs);
                                
                                // 检查是否正在进行中
                                if (nowCST >= currentEventStartCST && nowCST < currentEventEndCST) {
                                    return {
                                        startTime: currentEventStartCST,
                                        location: ""
                                    };
                                }
                                
                                // 如果当前时间在时间段内，寻找下一个间隔的事件
                                if (nowCST >= dayRangeStartCST && nowCST < dayRangeEndCST) {
                                    let nextInterval = currentInterval + 1;
                                    let nextEventStartCST = new Date(dayRangeStartCST.getTime() + nextInterval * intervalMs);
                                    let nextEventEndCST = new Date(nextEventStartCST.getTime() + durationMs);
                                    
                                    // 确保下一个事件在时间段内
                                    if (nextEventStartCST < dayRangeEndCST) {
                                        return {
                                            startTime: nextEventStartCST,
                                            location: ""
                                        };
                                    }
                                } else if (nowCST >= dayRangeEndCST) {
                                    // 当前时间已经过了今天的时间段，继续检查下一个符合条件的日期
                                    continue;
                                }
                                
                                // 只有当当前检查的日期是今天且时间在时间段之前，或者是未来的日期时，才添加到候选列表
                                // 确保我们只添加未来的时间点
                                let nextInterval = 0;
                                let nextEventStartCST = new Date(dayRangeStartCST.getTime() + nextInterval * intervalMs);
                                
                                // 如果是今天的日期，确保时间点在当前时间之后
                                if (i === 0) {
                                    if (nextEventStartCST > nowCST) {
                                        candidates.push(nextEventStartCST);
                                    }
                                } else {
                                    // 未来的日期直接添加
                                    candidates.push(nextEventStartCST);
                                }
                            }
                        }
                        
                        // 选择最近的时间点
                        if (candidates.length > 0) {
                            candidates.sort((a, b) => a - b);
                            return {
                                startTime: candidates[0],
                                location: ""
                            };
                        }
                    } else {
                        // 非间隔重复的情况
                        const candidates = [];
                        const allTimePoints = []; // 用于检查正在进行中的事件的所有时间点
                        
                        // 检查未来30天内的所有符合条件的星期几和时间点组合，而不是7天，确保能找到在startDate之后的日期
                        for (let i = 0; i < 30; i++) {
                            const checkDay = (todayWeekday + i) % 7;
                            if (task.recurrence.weekdays.includes(checkDay)) {
                                if (task.recurrence.weeklyRepeatType === "time-range" && task.recurrence.rangeStart) {
                                    // time-range模式，使用rangeStart作为时间点
                                    const [rangeStartHour, rangeStartMinute] = task.recurrence.rangeStart.split(':').map(Number);
                                    const testDatePDT = new Date(nowPDT);
                                    testDatePDT.setDate(testDatePDT.getDate() + i);
                                    testDatePDT.setHours(rangeStartHour, rangeStartMinute, 0, 0);
                                    
                                    // 检查是否在startDate之后
                                    if (testDatePDT < initialStartPDT) {
                                        continue; // 跳过在startDate之前的日期
                                    }
                                    
                                    allTimePoints.push(testDatePDT);
                                    if (testDatePDT > nowPDT) {
                                        candidates.push(testDatePDT);
                                    }
                                } else {
                                    // time-points模式或其他，使用所有时间点
                                    for (const { hour, minute } of timePoints) {
                                        const testDatePDT = new Date(nowPDT);
                                        testDatePDT.setDate(testDatePDT.getDate() + i);
                                        testDatePDT.setHours(hour, minute, 0, 0);
                                        
                                        // 检查是否在startDate之后
                                        if (testDatePDT < initialStartPDT) {
                                            continue; // 跳过在startDate之前的日期
                                        }
                                        
                                        allTimePoints.push(testDatePDT);
                                        if (testDatePDT > nowPDT) {
                                            candidates.push(testDatePDT);
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 计算持续时间
                        let durationMs;
                        if (task.recurrence.weeklyRepeatType === "time-range" && task.recurrence.rangeStart && task.recurrence.rangeEnd) {
                            // 对于time-range模式，计算rangeStart和rangeEnd之间的时长
                            const [rangeStartHour, rangeStartMinute] = task.recurrence.rangeStart.split(':').map(Number);
                            const [rangeEndHour, rangeEndMinute] = task.recurrence.rangeEnd.split(':').map(Number);
                            const rangeStartMinutes = rangeStartHour * 60 + rangeStartMinute;
                            const rangeEndMinutes = rangeEndHour * 60 + rangeEndMinute;
                            const rangeDurationMinutes = rangeEndMinutes >= rangeStartMinutes ? rangeEndMinutes - rangeStartMinutes : 1440 + rangeEndMinutes - rangeStartMinutes;
                            durationMs = rangeDurationMinutes * 60 * 1000;
                        } else {
                            // 其他情况使用原来的duration计算
                            durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                        }
                        
                        // 首先检查所有时间点（包括今天已经过去的时间点），看是否有正在进行中的事件
                        for (const timePoint of allTimePoints) {
                            const timePointCST = TimeZoneUtils.PDTtoCST(timePoint);
                            if (timePointCST <= nowCST && nowCST < timePointCST.getTime() + durationMs) {
                                return {
                                    startTime: timePointCST,
                                    location: ""
                                };
                            }
                        }
                        
                        // 如果没有正在进行中的事件，选择最近的未来时间点
                        if (candidates.length > 0) {
                            candidates.sort((a, b) => a - b);
                            
                            // 如果candidates数组中有今天的时间点，优先选择今天的
                            // 否则选择第一个时间点
                            const nextTimeCST = TimeZoneUtils.PDTtoCST(candidates[0]);
                            return {
                                startTime: nextTimeCST,
                                location: ""
                            };
                        }
                    }
                    
                    // 如果没有找到合适的时间点，返回当前时间后的第一个星期几的时间点
                    nextTimePDT.setHours(startHour, startMinute, 0, 0);
                    return {
                        startTime: TimeZoneUtils.PDTtoCST(nextTimePDT),
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "interval") {
                    // 自定义间隔重复
                    const intervalMs = convertToMilliseconds(task.recurrence.count, task.recurrence.unit);
                    
                    // 解析结束时间
                    let endPDT = null;
                    if (task.recurrence.endDate && task.recurrence.endTime) {
                        const endDateStr = task.recurrence.endDate;
                        const endTimeStr = task.recurrence.endTime;
                        const [endYear, endMonth, endDay] = endDateStr.split('-').map(Number);
                        const [endHour, endMinute] = endTimeStr.split(':').map(Number);
                        endPDT = new Date(endYear, endMonth - 1, endDay, endHour, endMinute, 0, 0);
                        
                        // 检查当前时间是否已经超过结束时间
                        if (nowPDT > endPDT) {
                            return null; // 当前时间已超过结束时间，事件不再显示
                        }
                    }
                    
                    // 检查初始开始时间是否在未来
                    if (initialStartPDT > nowPDT) {
                        // 初始开始时间在未来，检查是否在结束时间之前
                        if (endPDT && initialStartPDT > endPDT) {
                            return null; // 开始时间超过结束时间，没有发生
                        }
                        
                        return {
                            startTime: TimeZoneUtils.PDTtoCST(initialStartPDT),
                            location: ""
                        };
                    }
                    
                    // 计算上次发生时间
                    const timeDiff = nowPDT - initialStartPDT;
                    const intervals = Math.floor(timeDiff / intervalMs);
                    const lastOccurrencePDT = new Date(initialStartPDT.getTime() + intervals * intervalMs);
                    const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                    
                    const lastOccurrenceCST = TimeZoneUtils.PDTtoCST(lastOccurrencePDT);
                    const lastOccurrenceEndPDT = new Date(lastOccurrencePDT.getTime() + durationMs);
                    
                    // 检查上次事件是否已超过结束时间
                    if (endPDT && lastOccurrenceEndPDT > endPDT) {
                        return null; // 上次事件的结束时间已超过结束时间，事件不再显示
                    }
                    
                    // 检查当前是否在事件持续时间内
                    if (nowCST <= lastOccurrenceCST.getTime() + durationMs) {
                        return {
                            startTime: lastOccurrenceCST,
                            location: ""
                        };
                    }
                    
                    // 计算下一次发生时间
                    const nextOccurrencePDT = new Date(lastOccurrencePDT.getTime() + intervalMs);
                    
                    // 检查下一次发生时间是否超过结束时间
                    if (endPDT && nextOccurrencePDT > endPDT) {
                        return null; // 下一次发生时间超过结束时间，没有下一次发生
                    }
                    
                    return {
                        startTime: TimeZoneUtils.PDTtoCST(nextOccurrencePDT),
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "monthly") {
                    // 每月重复
                    const monthdays = task.recurrence.days || task.recurrence.monthdays || task.recurrence.startDates;
                    // 使用默认日期（1号）如果没有指定日期
                    const days = monthdays && monthdays.length > 0 ? 
                        monthdays.map(Number).sort((a, b) => a - b) : [1];
                    
                    // 获取所有时间点，如果没有则使用当前的startHour和startMinute
                    let timePoints = [];
                    
                    // 检查是否是time-range模式
                    if (task.recurrence.monthlyRepeatType === "time-range" && task.recurrence.rangeStart && task.recurrence.rangeEnd) {
                        // 时间段模式：根据rangeStart、rangeEnd、intervalCount和intervalUnit生成时间点
                        const [startHour, startMinute] = task.recurrence.rangeStart.split(':').map(Number);
                        const [endHour, endMinute] = task.recurrence.rangeEnd.split(':').map(Number);
                        const intervalCount = parseInt(task.recurrence.intervalCount) || 1;
                        const intervalUnit = task.recurrence.intervalUnit || 'hour';
                        
                        // 计算间隔毫秒数
                        const intervalMs = convertToMilliseconds(intervalCount, intervalUnit);
                        
                        // 创建开始和结束时间的Date对象（使用当天日期作为基础）
                        const startDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), nowPDT.getDate(), startHour, startMinute, 0, 0);
                        const endDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), nowPDT.getDate(), endHour, endMinute, 0, 0);
                        
                        // 生成时间段内所有的时间点
                        let currentTimePDT = new Date(startDatePDT);
                        while (currentTimePDT <= endDatePDT) {
                            timePoints.push({ 
                                hour: currentTimePDT.getHours(), 
                                minute: currentTimePDT.getMinutes() 
                            });
                            currentTimePDT.setTime(currentTimePDT.getTime() + intervalMs);
                        }
                    } else {
                        // 时间点模式：使用startTimes数组或默认时间点
                        timePoints = task.recurrence.startTimes && task.recurrence.startTimes.length > 0 ? 
                            task.recurrence.startTimes.map(timeStr => {
                                const [h, m] = timeStr.split(':').map(Number);
                                return { hour: h, minute: m };
                            }) : [{ hour: startHour, minute: startMinute }];
                    }
                    
                    let found = false;
                    let nextTimePDT = null;
                    
                    // 首先检查当前是否正在进行中
                    const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                    
                    // 检查当前月份和上个月的所有日期和时间点组合，看是否有正在进行中的任务
                    for (let monthOffset = -1; monthOffset <= 0; monthOffset++) {
                        for (let i = 0; i < days.length; i++) {
                            const day = days[i];
                            for (let j = 0; j < timePoints.length; j++) {
                                const { hour, minute } = timePoints[j];
                                // 创建PDT时间对象，考虑当前月和上个月
                                const testDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth() + monthOffset, day, hour, minute, 0, 0);
                                const testDateCST = TimeZoneUtils.PDTtoCST(testDatePDT);
                                
                                // 检查当前时间是否在这个时间点的任务持续时间内
                                if (testDateCST <= nowCST && nowCST < testDateCST.getTime() + durationMs) {
                                    // 找到正在进行中的任务，直接返回
                                    return {
                                        startTime: testDateCST,
                                        location: ""
                                    };
                                }
                            }
                        }
                    }
                    
                    // 尝试在当前月份找到所有合适的日期和时间点组合
                    const currentMonthCandidates = [];
                    for (let i = 0; i < days.length; i++) {
                        const day = days[i];
                        for (let j = 0; j < timePoints.length; j++) {
                            const { hour, minute } = timePoints[j];
                            // 直接创建PDT时间对象
                            const testDatePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), day, hour, minute, 0, 0);
                            
                            if (testDatePDT > nowPDT) {
                                currentMonthCandidates.push(testDatePDT);
                            }
                        }
                    }
                    
                    // 如果当前月份有合适的日期和时间点组合，选择最近的一个（最小的日期和时间）
                    if (currentMonthCandidates.length > 0) {
                        currentMonthCandidates.sort((a, b) => a - b);
                        nextTimePDT = currentMonthCandidates[0];
                        found = true;
                    }
                    
                    // 如果当前月份没有找到，在下个月寻找所有有效日期和时间点组合
                    if (!found) {
                        // 创建下个月的PDT时间
                        const nextMonthPDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth() + 1, 1);
                        
                        let daysInMonth = new Date(nextMonthPDT.getFullYear(), nextMonthPDT.getMonth() + 1, 0).getDate();
                        
                        const nextMonthCandidates = [];
                        for (let i = 0; i < days.length; i++) {
                            const day = days[i];
                            if (day <= daysInMonth) {
                                for (let j = 0; j < timePoints.length; j++) {
                                    const { hour, minute } = timePoints[j];
                                    // 直接创建PDT时间对象
                                    const candidatePDT = new Date(nextMonthPDT.getFullYear(), nextMonthPDT.getMonth(), day, hour, minute, 0, 0);
                                    nextMonthCandidates.push(candidatePDT);
                                }
                            }
                        }
                        
                        // 如果下个月有有效日期和时间点组合，选择最近的一个（最小的日期和时间）
                        if (nextMonthCandidates.length > 0) {
                            nextMonthCandidates.sort((a, b) => a - b);
                            nextTimePDT = nextMonthCandidates[0];
                            found = true;
                        }
                        
                        // 如果还是没找到（例如2月没有30日），使用下个月的第一个有效日期和第一个时间点
                        if (!found) {
                            const maxDay = Math.min(days[0], daysInMonth);
                            const { hour, minute } = timePoints[0];
                            // 直接创建PDT时间对象
                            nextTimePDT = new Date(nextMonthPDT.getFullYear(), nextMonthPDT.getMonth(), maxDay, hour, minute, 0, 0);
                        }
                    }
                    
                    // 确保nextTimePDT已经被设置
                    if (!nextTimePDT) {
                        const { hour, minute } = timePoints[0];
                        // 直接创建PDT时间对象
                        nextTimePDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), days[0], hour, minute, 0, 0);
                    }
                    
                    return {
                        startTime: TimeZoneUtils.PDTtoCST(nextTimePDT),
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "monthly_interval") {
                    // 每月+间隔重复
                    // 遵循全局时区转换原则：所有时间计算都在PDT时间域内进行，仅在返回结果时转换为CST时间
                    
                    // 1. 解析基本参数
                    const days = task.recurrence.days && task.recurrence.days.length > 0 ? 
                        task.recurrence.days.map(Number).sort((a, b) => a - b) : [1];
                    
                    // 使用云端数据中的正确字段名：count和unit
                    const intervalCount = task.recurrence.count || 1;
                    const intervalUnit = task.recurrence.unit || "hour"; // 默认小时间隔
                    const intervalMs = convertToMilliseconds(intervalCount, intervalUnit);
                    
                    // 2. 解析时间点（startTimes中的时间是PDT时间）
                    let timePoints = [];
                    if (task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                        timePoints = task.recurrence.startTimes.map(timeStr => {
                            const [h, m] = timeStr.split(':').map(Number);
                            return { hour: h, minute: m };
                        });
                    } else {
                        timePoints = [{ hour: startHour, minute: startMinute }];
                    }
                    
                    // 3. 计算事件持续时间（毫秒）
                    const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                    
                    // 4. 初始化变量
                    let found = false;
                    let nextTimePDT = null;
                    const allCandidates = [];
                    
                    // 5. 遍历所有指定的日期
                    for (let day of days) {
                        // 创建当前月份的PDT时间对象
                        const currentMonthPDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth(), 1);
                        
                        // 创建当天的PDT时间
                        let targetDatePDT = new Date(currentMonthPDT);
                        targetDatePDT.setDate(day);
                        
                        // 检查日期是否在当前日期之前
                        if (targetDatePDT < nowPDT && targetDatePDT.getDate() < nowPDT.getDate()) {
                            // 如果是，设置为下个月的同一日期
                            targetDatePDT.setMonth(targetDatePDT.getMonth() + 1);
                        }
                        
                        // 6. 遍历所有时间点
                        for (let timePoint of timePoints) {
                            const { hour, minute } = timePoint;
                            
                            // 创建当天的起始时间点（PDT时间）
                            let currentTimePointPDT = new Date(targetDatePDT);
                            currentTimePointPDT.setHours(hour, minute, 0, 0);
                            
                            // 7. 检查当天内所有符合条件的时间点
                            let tempTimePointPDT = new Date(currentTimePointPDT);
                            while (tempTimePointPDT.getDate() === day) {
                                // 转换为CST时间用于比较
                                const tempTimePointCST = TimeZoneUtils.PDTtoCST(tempTimePointPDT);
                                
                                // 检查是否正在进行中
                                if (nowCST >= tempTimePointCST && nowCST < tempTimePointCST.getTime() + durationMs) {
                                    return {
                                        startTime: tempTimePointCST,
                                        location: ""
                                    };
                                }
                                
                                // 检查是否是未来的时间点
                                if (tempTimePointCST >= nowCST) {
                                    allCandidates.push(tempTimePointPDT);
                                    break; // 只添加第一个符合条件的时间点
                                }
                                
                                // 计算下一个间隔时间点
                                tempTimePointPDT = new Date(tempTimePointPDT.getTime() + intervalMs);
                            }
                        }
                    }
                    
                    // 8. 处理候选时间点
                    if (allCandidates.length > 0) {
                        // 按时间顺序排序
                        allCandidates.sort((a, b) => a - b);
                        // 选择最近的时间点
                        nextTimePDT = allCandidates[0];
                        found = true;
                    }
                    
                    // 9. 如果当前月份没有找到合适的时间点，检查下个月
                    if (!found) {
                        // 创建下个月的PDT时间对象
                        const nextMonthPDT = new Date(nowPDT.getFullYear(), nowPDT.getMonth() + 1, 1);
                        
                        // 获取下个月的天数
                        const daysInNextMonth = new Date(nextMonthPDT.getFullYear(), nextMonthPDT.getMonth() + 1, 0).getDate();
                        
                        // 遍历所有指定的日期
                        for (let day of days) {
                            // 检查日期是否有效（例如2月没有30日）
                            if (day <= daysInNextMonth) {
                                // 创建下个月的目标日期
                                let targetDatePDT = new Date(nextMonthPDT);
                                targetDatePDT.setDate(day);
                                
                                // 遍历所有时间点
                                for (let timePoint of timePoints) {
                                    const { hour, minute } = timePoint;
                                    
                                    // 创建当天的起始时间点（PDT时间）
                                    let currentTimePointPDT = new Date(targetDatePDT);
                                    currentTimePointPDT.setHours(hour, minute, 0, 0);
                                    
                                    // 添加到候选列表
                                    allCandidates.push(currentTimePointPDT);
                                }
                            }
                        }
                        
                        // 处理下个月的候选时间点
                        if (allCandidates.length > 0) {
                            allCandidates.sort((a, b) => a - b);
                            nextTimePDT = allCandidates[0];
                            found = true;
                        }
                    }
                    
                    // 10. 如果还是没找到，使用默认值
                    if (!found) {
                        // 选择第一个有效的日期和时间点
                        const firstDay = days[0];
                        const firstTimePoint = timePoints[0];
                        const { hour, minute } = firstTimePoint;
                        
                        // 创建默认时间点
                        nextTimePDT = new Date(nowPDT);
                        nextTimePDT.setDate(firstDay);
                        nextTimePDT.setHours(hour, minute, 0, 0);
                        
                        // 如果日期已过，设置为下个月
                        if (nextTimePDT < nowPDT) {
                            nextTimePDT.setMonth(nextTimePDT.getMonth() + 1);
                        }
                    }
                    
                    // 11. 转换为CST时间返回结果
                    const nextTimeCST = TimeZoneUtils.PDTtoCST(nextTimePDT);
                    return {
                        startTime: nextTimeCST,
                        location: ""
                    };
                }
                
                if (task.recurrence.type === "custom") {
                    // 自定义间隔重复
                    const intervalMs = convertToMilliseconds(task.recurrence.count, task.recurrence.unit);
                    const timeDiff = nowPDT - initialStartPDT;
                    const intervals = Math.floor(timeDiff / intervalMs);
                    
                    const lastOccurrencePDT = new Date(initialStartPDT.getTime() + intervals * intervalMs);
                    const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                    
                    const lastOccurrenceCST = TimeZoneUtils.PDTtoCST(lastOccurrencePDT);
                    
                    if (nowCST <= lastOccurrenceCST.getTime() + durationMs) {
                        return {
                            startTime: lastOccurrenceCST,
                            location: ""
                        };
                    }
                    
                    const nextOccurrencePDT = new Date(lastOccurrencePDT.getTime() + intervalMs);
                    return {
                        startTime: TimeZoneUtils.PDTtoCST(nextOccurrencePDT),
                        location: ""
                    };
                }
                
                // 默认返回1小时后
                return {
                    startTime: new Date(nowCST.getTime() + 60 * 60 * 1000),
                    location: ""
                };
                
            } catch (e) {
                console.error('计算下次发生时间出错:', task.name, e);
                return {
                    startTime: new Date(nowCST.getTime() + 60 * 60 * 1000),
                    location: ""
                };
            }
        }

        // 获取事件状态信息 - 修复状态计算逻辑
        function getTaskStatus(task, nowCST) {
            // 缓存重复计算的值
            const thresholdMs = convertToMilliseconds(task.displayThreshold, task.displayThresholdUnit);
            const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
            
            try {
                // 特殊处理破晓红石和圆梦滑冰事件
                if (task.recurrence.type === "custom_complex") {
                    let activeInfo, nextOccurrence;
                    let location = "";
                    
                    if (task.recurrence.pattern === "dawn_redstone") {
                        activeInfo = isDawnRedstoneActive(nowCST);
                        location = "破晓红石位置";
                        
                        if (activeInfo) {
                            // 当前正在进行破晓红石事件
                            const timeLeft = activeInfo.endTime - nowCST;
                            const displayStartTimeCST = new Date(activeInfo.startTime.getTime() - thresholdMs);
                            
                            return {
                                status: "ongoing",
                                timeText: `正在进行`,
                                countdownMs: timeLeft,
                                countdownText: formatCountdown(timeLeft),
                                minutes: Math.ceil(timeLeft / (1000 * 60)),
                                startTime: activeInfo.startTime,
                                endTime: activeInfo.endTime,
                                displayStartTime: displayStartTimeCST,
                                displayEndTime: activeInfo.endTime,
                                location: activeInfo.location
                            };
                        }
                        
                        nextOccurrence = getNextDawnRedstoneOccurrence(nowCST);
                        if (!nextOccurrence || !nextOccurrence.startTime) {
                            return createDefaultStatus(nowCST, "未来事件", 0, "--");
                        }
                        location = nextOccurrence.location;
                    } else if (task.recurrence.pattern === "dream_skating") {
                        activeInfo = DreamSkatingRules.isActive(nowCST);
                        location = "圆梦村";
                        
                        if (activeInfo) {
                            // 当前正在进行圆梦滑冰事件
                            const timeLeft = activeInfo.endTime - nowCST;
                            const displayStartTimeCST = new Date(activeInfo.startTime.getTime() - thresholdMs);
                            
                            return {
                                status: "ongoing",
                                timeText: `正在进行`,
                                countdownMs: timeLeft,
                                countdownText: formatCountdown(timeLeft),
                                minutes: Math.ceil(timeLeft / (1000 * 60)),
                                startTime: activeInfo.startTime,
                                endTime: activeInfo.endTime,
                                displayStartTime: displayStartTimeCST,
                                displayEndTime: activeInfo.endTime,
                                location: location
                            };
                        }
                        
                        nextOccurrence = DreamSkatingRules.getNextOccurrence(nowCST);
                        if (!nextOccurrence || !nextOccurrence.startTime) {
                            return createDefaultStatus(nowCST, "未来事件", 0, "--");
                        }
                    }
                    
                    if (nextOccurrence) {
                        const nextStartCST = nextOccurrence.startTime;
                        const endTimeCST = new Date(nextStartCST.getTime() + durationMs);
                        const timeUntilStart = nextStartCST - nowCST;
                        const displayStartTimeCST = new Date(nextStartCST.getTime() - thresholdMs);
                        
                        // 检查事件是否已结束
                        if (nowCST > endTimeCST) {
                            return {
                                status: "completed",
                                timeText: "已完成",
                                countdownMs: 0,
                                countdownText: "已完成",
                                minutes: Infinity,
                                startTime: nextStartCST,
                                endTime: endTimeCST,
                                displayStartTime: displayStartTimeCST,
                                displayEndTime: endTimeCST,
                                location: location
                            };
                        }
                        
                        const isInDisplayRange = nowCST >= displayStartTimeCST;
                        const isOngoing = nowCST >= nextStartCST && nowCST < endTimeCST;
                        
                        let timeText;
                        if (isOngoing) {
                            timeText = "正在进行";
                        } else if (timeUntilStart < 0) {
                            timeText = "已开始";
                        } else {
                            const converted = convertFromMilliseconds(timeUntilStart);
                            timeText = `${converted.value}${converted.text}后`; //特殊事件的即将开始后缀
                        }
                        
                        return {
                            status: isOngoing ? "ongoing" : (isInDisplayRange ? "upcoming" : "future"),
                            timeText: timeText,
                            countdownMs: isOngoing ? (endTimeCST - nowCST) : timeUntilStart,
                            countdownText: formatCountdown(isOngoing ? (endTimeCST - nowCST) : timeUntilStart),
                            minutes: Math.ceil((isOngoing ? (endTimeCST - nowCST) : timeUntilStart) / (1000 * 60)),
                            startTime: nextStartCST,
                            endTime: endTimeCST,
                            displayStartTime: displayStartTimeCST,
                            displayEndTime: endTimeCST,
                            location: location
                        };
                    }
                }
                
                // 普通事件处理
                const nextOccurrence = getNextOccurrence(task, nowCST);
                if (!nextOccurrence || !nextOccurrence.startTime) {
                    // 如果没有下一次发生时间，返回已完成状态
                    return {
                        status: "completed",
                        timeText: "已结束",
                        countdownMs: 0,
                        countdownText: "已结束",
                        minutes: Infinity,
                        startTime: nowCST,
                        endTime: nowCST,
                        displayStartTime: nowCST,
                        displayEndTime: nowCST,
                        location: task.location || ""
                    };
                }
                
                const nextStartCST = nextOccurrence.startTime;
                const location = task.location || "";
                const endTimeCST = new Date(nextStartCST.getTime() + durationMs);
                const displayStartTimeCST = new Date(nextStartCST.getTime() - thresholdMs);
                
                const isInDisplayRange = nowCST >= displayStartTimeCST;
                const isOngoing = nowCST >= nextStartCST && nowCST < endTimeCST;
                const timeUntilStart = nextStartCST - nowCST;
                
                // 单次事件且已结束
                if (task.recurrence.type === "none" && nowCST > endTimeCST) {
                    return {
                        status: "completed",
                        timeText: "已完成",
                        countdownMs: 0,
                        countdownText: "已完成",
                        minutes: Infinity,
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                }
                
                if (isOngoing) {
                    const timeLeft = endTimeCST - nowCST;
                    return {
                        status: "ongoing",
                        timeText: `正在进行`,
                        countdownMs: timeLeft,
                        countdownText: formatCountdown(timeLeft),
                        minutes: Math.ceil(timeLeft / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                } else if (isInDisplayRange) {
                    const converted = convertFromMilliseconds(timeUntilStart);
                    return {
                        status: "upcoming",
                        timeText: `${converted.value}${converted.text}后`, // 即将开始后缀  
                        countdownMs: timeUntilStart,
                        countdownText: formatCountdown(timeUntilStart),
                        minutes: Math.ceil(timeUntilStart / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                } else {
                    const converted = convertFromMilliseconds(timeUntilStart);
                    return {
                        status: "future",
                        timeText: `${converted.value}${converted.text}后`, // 新即将开始后缀  
                        countdownMs: timeUntilStart,
                        countdownText: formatCountdown(timeUntilStart),
                        minutes: Math.ceil(timeUntilStart / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                }
            } catch (e) {
                console.error('计算任务状态出错:', task.name, e);
                return createDefaultStatus(nowCST, "时间计算中", 0, "--");
            }
        }
        
        // 创建默认状态对象
        function createDefaultStatus(nowCST, timeText, countdownMs, countdownText) {
            return {
                status: "future",
                timeText: timeText,
                countdownMs: countdownMs,
                countdownText: countdownText,
                minutes: Infinity,
                startTime: nowCST,
                endTime: new Date(nowCST.getTime() + 60 * 60 * 1000),
                displayStartTime: nowCST,
                displayEndTime: new Date(nowCST.getTime() + 60 * 60 * 1000),
                location: ""
            };
        }

        // 过滤出需要显示的事件
        function getVisibleTasks() {
            const nowCST = new Date();
            const visibleTasks = [];
            
            // 预先定义优先级顺序，避免重复创建对象
            const priorityOrder = { high: 3, medium: 2, low: 1 };
            
            // 使用for循环替代map+filter，减少数组遍历次数
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                
                // 先过滤掉优先级为none的任务，避免不必要的计算
                if (task.priority === "none") {
                    continue;
                }
                
                // 获取任务状态
                const status = getTaskStatus(task, nowCST);
                
                // 只保留正在进行或即将开始的任务
                if (status.status !== "completed" && 
                    (status.status === "ongoing" || status.status === "upcoming")) {
                    // 合并任务和状态信息
                    visibleTasks.push({
                        ...task,
                        ...status
                    });
                }
            }
            
            // 排序可见任务
            visibleTasks.sort((a, b) => {
                // 先按优先级排序
                if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                
                // 再按状态排序（正在进行的任务优先）
                if (a.status === "ongoing" && b.status !== "ongoing") return -1;
                if (a.status !== "ongoing" && b.status === "ongoing") return 1;
                
                // 最后按剩余时间排序
                return a.minutes - b.minutes;
            });
            
            return visibleTasks;
        }

        // 获取所有事件（用于悬停显示）
        function getAllTasksWithStatus() {
            const nowCST = new Date();
            const allTasks = [];
            
            // 预先定义优先级顺序，避免重复创建对象
            const priorityOrder = { high: 3, medium: 2, low: 1, none: 0 };
            
            // 使用for循环替代map+filter，减少数组遍历次数
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                
                try {
                    const status = getTaskStatus(task, nowCST);
                    
                    // 只保留未完成的任务
                    if (status.status !== "completed") {
                        allTasks.push({
                            ...task,
                            ...status
                        });
                    }
                } catch (e) {
                    console.error('计算任务状态出错:', task.name, e);
                    allTasks.push({
                        ...task,
                        status: "future",
                        timeText: "时间计算中",
                        countdownMs: 0,
                        countdownText: "--",
                        minutes: Infinity,
                        startTime: new Date(),
                        endTime: new Date(),
                        displayStartTime: new Date(),
                        displayEndTime: new Date()
                    });
                }
            }
            
            // 排序所有任务
            allTasks.sort((a, b) => {
                // 先按优先级过滤规则排序
                if (a.priority === "none" && b.priority !== "none") return 1;
                if (a.priority !== "none" && b.priority === "none") return -1;
                
                // 再按优先级排序
                if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                
                // 最后按开始时间排序
                return (a.startTime || new Date()) - (b.startTime || new Date());
            });
            
            return allTasks;
        }

        // 全局图片缓存，避免重复查找
        const imageCache = {};

        // 创建事件元素
        function createTaskElement(task) {
            const taskEl = document.createElement('div');
            const baseClass = "task-item p-4 rounded-2xl mb-3 task-transition bg-dark-bg shadow-sm mx-auto max-w-md relative overflow-hidden";
            
            taskEl.className = baseClass;
            taskEl.dataset.taskId = task.id;
            
            let recurrenceText = "";
            // 定义单位名称映射，在所有case中共享使用
            const unitNames = {
                "minute": "分钟",
                "hour": "小时",
                "day": "天",
                "week": "周",
                "month": "月"
            };
            
            if (task.recurrence.type === "custom_complex" && task.recurrence.pattern === "dawn_redstone") {
                recurrenceText = "红石规则";
            } else if (task.recurrence.type === "custom_complex" && task.recurrence.pattern === "dream_skating") {
                recurrenceText = "滑冰规则";
            } else {
                switch(task.recurrence.type) {
                    case "none":
                        recurrenceText = "不重复";
                        break;
                    case "daily":
                        // 显示每天的所有时间点（将太平洋时间转换为北京时间后显示）
                        if (task.recurrence.dailyRepeatType === "time-range" && task.recurrence.rangeStart) {
                            // 时间段模式：显示rangeStart作为开始时间
                            const [startHour, startMinute] = task.recurrence.rangeStart.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            const cstTime = TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            recurrenceText = `每天 ${cstTime}`;
                            
                            // 如果是时间段重复模式且有间隔信息，添加间隔显示
                            if (task.recurrence.intervalCount && task.recurrence.intervalUnit) {
                                const intervalCount = task.recurrence.intervalCount;
                                const intervalUnit = unitNames[task.recurrence.intervalUnit] || "小时";
                                recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                            }
                        } else if (task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                            // 时间点模式：显示所有时间点
                            const cstTimes = task.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText = `每天 ${cstTimes.join(', ')}`;
                        } else {
                            recurrenceText = "每天";
                        }
                        break;
                    case "weekly":
                        const dayNames = ["日", "一", "二", "三", "四", "五", "六"];
                        const selectedDays = task.recurrence.weekdays?.map(day => dayNames[day]).join('') || "";
                        
                        // 显示每周的所有时间点（将太平洋时间转换为北京时间后显示）
                        if (task.recurrence.weeklyRepeatType === "time-points" && task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                            const cstTimes = task.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                // 创建正确的PDT时间对象
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText = `每周${selectedDays} ${cstTimes.join(', ')}`;
                        } else {
                            recurrenceText = `每周${selectedDays}`;
                        }
                        
                        // 如果是时间段重复模式且有间隔信息，添加间隔显示
                        if (task.recurrence.weeklyRepeatType === "time-range" && task.recurrence.intervalCount && task.recurrence.intervalUnit) {
                            const intervalCount = task.recurrence.intervalCount;
                            const intervalUnit = unitNames[task.recurrence.intervalUnit] || "小时";
                            recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                        }
                        break;
                    case "monthly":
                        const monthDayNames = ["日", "一", "二", "三", "四", "五", "六"];
                        if (task.recurrence.weekdays && task.recurrence.weekdays.length > 0) {
                            const selectedWeekDays = task.recurrence.weekdays?.map(day => monthDayNames[day]).join(', ') || "";
                            recurrenceText = `每月${selectedWeekDays}`;
                        } else {
                            // 使用days属性，支持多个日期
                            const monthdays = (task.recurrence.days && task.recurrence.days.length > 0) ? task.recurrence.days : 
                                              (task.recurrence.monthdays && task.recurrence.monthdays.length > 0) ? task.recurrence.monthdays : 
                                              task.recurrence.startDates;
                            if (monthdays && monthdays.length > 0) {
                                const selectedDays = monthdays.join(', ') || "";
                                recurrenceText = `每月${selectedDays}日`;
                            } else {
                                recurrenceText = "每月1日";
                            }
                        }
                        
                        // 显示所有时间点（如果有指定）
                        if (task.recurrence.monthlyRepeatType === 'time-points' && task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                            // 将所有太平洋时间转换为北京时间后显示
                            const cstTimes = task.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText += ` ${cstTimes.join(', ')}`;
                        } else if (task.recurrence.startTime) {
                            // 将太平洋时间转换为北京时间后显示
                            if (typeof task.recurrence.startTime === 'string') {
                                const [startHour, startMinute] = task.recurrence.startTime.split(':').map(Number);
                                // 创建正确的PDT时间对象
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                            }
                        } else if (task.startTime) {
                            if (typeof task.startTime === 'string') {
                                const [startHour, startMinute] = task.startTime.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                            } else {
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(task.startTime)}`;
                            }
                        }
                        break;
                    case "interval":
                    case "custom":
                        const intervalCount = task.recurrence.count || 1;
                        const intervalUnit = unitNames[task.recurrence.unit] || "月";
                        recurrenceText = `每${intervalCount}${intervalUnit}`;
                        break;
                    case "monthly_interval":
                        // 显示每月的日期
                        const monthdays = task.recurrence.days && task.recurrence.days.length > 0 ? 
                            task.recurrence.days.join(', ') : "1";
                        recurrenceText = `每月${monthdays}日`;
                        // 显示所有时间点（如果有指定）
                        if (task.recurrence.monthlyRepeatType === 'time-points' && task.recurrence.startTimes && task.recurrence.startTimes.length > 0) {
                            // 将所有太平洋时间转换为北京时间后显示
                            const cstTimes = task.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText += ` ${cstTimes.join(', ')}`;
                        } else if (task.recurrence.startTime) {
                            // 将太平洋时间转换为北京时间后显示
                            const [startHour, startMinute] = task.recurrence.startTime.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                        } else if (task.startTime) {
                            // 将太平洋时间转换为北京时间后显示
                            if (typeof task.startTime === 'string') {
                                const [startHour, startMinute] = task.startTime.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                            } else {
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(task.startTime)}`;
                            }
                        }
                        // 显示间隔信息
                        const monthUnitNames = {
                            "minute": "分钟",
                            "hour": "小时",
                            "day": "天",
                            "week": "周",
                            "month": "月"
                        };
                        const intervalCountForMonth = task.recurrence.count || 1;
                        const intervalUnitForMonth = monthUnitNames[task.recurrence.unit] || "小时";
                        recurrenceText += ` 间隔${intervalCountForMonth}${intervalUnitForMonth}`;
                        break;
                }
            }
            
            const durationUnitNames = {
                "minute": "分钟",
                "hour": "小时",
                "day": "天",
                "week": "周"
            };
            const durationText = `${task.recurrence.duration}${durationUnitNames[task.recurrence.durationUnit]}`;
            
            // 处理多个时间点显示的变量 - 现在我们将时间点显示在重复栏中，时间栏只显示开始-结束时间
            
            // 使用北京时间显示，使用task.startTime作为实际开始时间，而不是task.displayStartTime（后者是显示阈值时间）
            let displayStartTime;
            
            // 对于monthly_interval和interval类型，使用getNextOccurrence获取正确的下一次发生时间
            if (task.recurrence.type === 'monthly_interval' || task.recurrence.type === 'interval' || task.recurrence.type === 'custom') {
                const nextOccurrence = getNextOccurrence(task, new Date());
                displayStartTime = nextOccurrence.startTime || new Date();
            } else {
                displayStartTime = task.startTime || 
                                    (() => {
                                        // 根据任务类型获取正确的开始时间字符串（太平洋时间）
                                        let timeStr;
                                        if (task.recurrence.type === 'daily' || task.recurrence.type === 'weekly') {
                                            timeStr = task.recurrence.startTimes?.[0] || '00:00';
                                        } else if (task.recurrence.type === 'monthly') {
                                            timeStr = task.recurrence.startTime || '00:00';
                                        } else if (task.recurrence.type === 'interval' || task.recurrence.type === 'custom') {
                                            timeStr = task.startTime || '00:00';
                                        } else {
                                            timeStr = task.startTime || '00:00';
                                        }
                                        
                                        // 确保timeStr是字符串
                                        const timeStrFinal = typeof timeStr === 'string' ? timeStr : '00:00';
                                        
                                        // 如果timeStrFinal是Date对象，直接返回
                                        if (timeStrFinal instanceof Date) {
                                            return timeStrFinal;
                                        }
                                        
                                        // 处理开始日期 - 确保正确获取年、月、日
                                        let year, month, day;
                                        if (typeof task.startDate === 'string') {
                                            [year, month, day] = task.startDate.split('-').map(Number);
                                        } else if (task.startDate instanceof Date) {
                                            // 如果是Date对象，直接获取年、月、日
                                            year = task.startDate.getFullYear();
                                            month = task.startDate.getMonth() + 1; // JavaScript月份从0开始
                                            day = task.startDate.getDate();
                                        } else {
                                            // 使用当前日期作为默认值
                                            const now = new Date();
                                            year = now.getFullYear();
                                            month = now.getMonth() + 1;
                                            day = now.getDate();
                                        }
                                        
                                        // 将太平洋时间转换为北京时间
                                        const [startHour, startMinute] = timeStrFinal.split(':').map(Number);
                                        
                                        // 创建太平洋时间的Date对象
                                        const pdtDate = new Date();
                                        pdtDate.setFullYear(year, month - 1, day); // 设置为指定的年月日
                                        pdtDate.setHours(startHour, startMinute, 0, 0); // 直接设置为太平洋时间
                                        
                                        return TimeZoneUtils.PDTtoCST(pdtDate);
                                    })();
            }
                                     
            const dateText = TimeZoneUtils.formatCSTDate(displayStartTime);
            let startTimeText, endTimeText;
            
            // 处理时间显示 - 所有情况都显示具体事件的开始和结束时间
            startTimeText = TimeZoneUtils.formatCSTTime(displayStartTime);
            const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
            const endTime = new Date(displayStartTime.getTime() + durationMs);
            endTimeText = TimeZoneUtils.formatCSTTime(endTime);
            
            const ongoingIndicator = task.status === "ongoing" ? 
                '<span class="inline-block w-2 h-2 bg-priority-high rounded-full ongoing-indicator mr-1"></span>' : '';
            
            const countdownBadge = `<span class="countdown ml-2">${task.countdownText}</span>`;
            
            const timeTextClass = task.status === "ongoing" ? "ongoing-text" : "";
            
            // 添加地点显示 - 为破晓红石事件添加特殊类
            const isDawnRedstone = task.name === "破晓 红石";
            const locationClass = isDawnRedstone ? "task-meta-item dawn-redstone-location" : "task-meta-item";
            // 处理地点对象，提取区域和名称，格式为：区域-地点名称
            const locationName = task.location ? (typeof task.location === 'object' ? `${task.location.area}-${task.location.name}` : task.location) : '';
            const locationText = locationName ? `<span class="${locationClass}"><i class="fa fa-map-marker mr-1 opacity-70"></i>${locationName}</span>` : '';
            
            taskEl.innerHTML = `
                <div class="flex justify-between items-center task-title">
                    <div class="font-medium text-dark-text flex items-center">
                        <span class="w-2 h-2 rounded-full mr-2 bg-priority-${task.priority}"></span>
                        ${task.name}
                    </div>
                    <div class="text-sm text-primary flex items-center">
                        ${ongoingIndicator}<span class="${timeTextClass}">${task.timeText}</span>${countdownBadge}
                    </div>
                </div>
                <div class="text-xs text-dark-textSecondary task-meta flex flex-col sm:flex-row sm:justify-between gap-1">
                    <span class="task-meta-item"><i class="fa fa-repeat mr-1 opacity-70"></i>${recurrenceText}</span>
                    <span class="task-meta-item"><i class="fa fa-clock-o mr-1 opacity-70"></i>持续 ${durationText}</span>
                    <span class="task-meta-item"><i class="fa fa-calendar mr-1 opacity-70"></i>${dateText}</span>
                    <span class="task-meta-item"><i class="fa fa-hourglass-start mr-1 opacity-70"></i>${startTimeText} - ${endTimeText}</span>
                    ${locationText}
                </div>
            `;
            
            // 尝试加载与事件ID对应的背景图 - 在innerHTML设置后添加，避免被覆盖
            const eventId = task.id;
            
            // 1. 检测设备类型：W-宽屏(电脑)，H-窄屏(手机)
            const isMobile = window.innerWidth < 640; // 手机宽度阈值
            const deviceType = isMobile ? 'H' : 'W';
            
            // 2. 检测主题类型：L-浅色，D-深色
            let themeType = 'D'; // 默认深色主题
            const dataTheme = document.documentElement.getAttribute('data-theme');
            if (dataTheme === 'light') {
                themeType = 'L';
            } else if (dataTheme === 'dark') {
                themeType = 'D';
            } else {
                // 检测系统主题偏好
                const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
                themeType = prefersLight ? 'L' : 'D';
            }
            
            // 3. 配置GitHub图库信息
            const githubUsername = 'sky-event';
            const githubRepo = 'sky-event.github.io';
            const githubBranch = 'main';
            const basePath = '163/images/event-bg';
            // 使用毫秒级时间戳，确保每次刷新都能获取最新图片
            const timestamp = Date.now();
            
            // 4. 定义图片查找优先级：从最具体到最通用
            // 新规则：W-宽屏(电脑)，H-窄屏(手机)，L-浅色，D-深色
            // 优先级顺序：
            // 1. 设备+主题：id{事件ID}-{设备类型}-{主题类型}.png
            // 2. 仅设备：id{事件ID}-{设备类型}.png
            // 3. 仅主题：id{事件ID}-{主题类型}.png
            // 4. 最通用：id{事件ID}.png
            const imageFilenames = [
                `id${eventId}-${deviceType}-${themeType}.png`, // 1. 设备+主题：例如 id3-H-L.png
                `id${eventId}-${deviceType}.png`,          // 2. 仅设备：例如 id3-W.png
                `id${eventId}-${themeType}.png`,          // 3. 仅主题：例如 id3-L.png
                `id${eventId}.png`                       // 4. 最通用：例如 id3.png
            ];
            
            // 5. 生成唯一的缓存键，包含事件ID、设备类型、主题类型
            const cacheKey = `${eventId}-${deviceType}-${themeType}`;
            
            // 检查缓存中是否已经有结果
            if (imageCache[cacheKey]) {
                // 使用缓存的图片URL，避免重复检测
                taskEl.style.backgroundImage = `url('${imageCache[cacheKey]}')`;
            } else {
                // 缓存中没有结果，开始查找
                let foundImageUrl = '';
                let found = false;
                
                // 递归查找可用图片
                function findAvailableImage(index) {
                    if (index >= imageFilenames.length || found) return;
                    
                    const filename = imageFilenames[index];
                const imagePath = `${basePath}/${filename}`;
                const imageUrl = `https://raw.githubusercontent.com/${githubUsername}/${githubRepo}/${githubBranch}/${imagePath}?t=${timestamp}`;
                    
                    // 检查该图片是否已在缓存中标记为不存在
                    if (imageCache[filename] === false) {
                        // 已确认不存在，尝试下一个
                        findAvailableImage(index + 1);
                        return;
                    }
                    
                    // 如果缓存中已有该图片的URL，直接使用
                    if (imageCache[filename]) {
                        foundImageUrl = imageCache[filename];
                        found = true;
                        return;
                    }
                    
                    // 否则，测试图片是否存在
                    const testImage = new Image();
                    testImage.onload = () => {
                        // 图片存在，缓存URL并返回
                        imageCache[filename] = imageUrl;
                        foundImageUrl = imageUrl;
                        found = true;
                    };
                    testImage.onerror = () => {
                        // 图片不存在，标记到缓存并尝试下一个
                        imageCache[filename] = false;
                        findAvailableImage(index + 1);
                    };
                    testImage.src = imageUrl;
                }
                
                // 开始查找可用图片
                findAvailableImage(0);
                
                // 使用setTimeout确保异步查找完成后设置背景图
                setTimeout(() => {
                    if (foundImageUrl) {
                        // 缓存最终结果，避免下次重复查找
                        imageCache[cacheKey] = foundImageUrl;
                        // 预加载图片，确保完全加载后再设置背景图，避免闪烁
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = function() {
                            // 图片完全加载后再设置背景图
                            taskEl.style.backgroundImage = `url('${foundImageUrl}')`;
                        };
                        img.src = foundImageUrl;
                    }
                }, 50);
            }
            // 添加平滑过渡效果，避免硬切
            taskEl.style.transition = 'background-image 0.5s ease-in-out';
            taskEl.style.backgroundSize = 'cover';
            // 根据设备类型设置不同的背景图定位
            if (deviceType === 'H') {
                // 手机端：右下角对齐
                taskEl.style.backgroundPosition = 'bottom right';
            } else {
                // 电脑端：上边缘居中对齐
                taskEl.style.backgroundPosition = 'top center';
            }
            taskEl.style.backgroundRepeat = 'no-repeat';
            taskEl.style.backgroundColor = 'var(--bg-color)'; // 使用主题背景色，不透明
            taskEl.style.backgroundBlendMode = 'normal'; // 正常混合模式，不使用叠加
            
            taskEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                hideAllContextMenus();
                
                currentTaskId = task.id;
                const x = e.clientX;
                const y = e.clientY;
                
                taskContextMenu.style.left = `${x}px`;
                taskContextMenu.style.top = `${y}px`;
                taskContextMenu.classList.remove('hidden');
            });
            
            return taskEl;
        }

        // 为未来事件列表中的任务添加点击交互
        function addClickInteractionToFutureTask(element, task) {
            element.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止事件冒泡
                
                // 如果点击的是同一个任务，则切换显示状态
                if (currentPreviewTaskId === task.id && isPreviewVisible) {
                    hidePreviewCard();
                } else {
                    // 显示新的预览卡片
                    showPreviewCard(task, e.clientX, e.clientY);
                }
            });
            
            // 为破晓红石事件添加双击跳转功能
            if (task.name === "破晓 红石") {
                element.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    // 跳转到 HHS.html
                    window.open('hhs.html', '_self');
                });
            }
        }

        // 创建缩略事件元素
        function createMiniTaskElement(task) {
            const taskEl = document.createElement('div');
            const baseClass = "flex justify-between items-center p-2 rounded-2xl bg-dark-bg border border-gray-700 cursor-pointer hover:bg-dark-hover future-task-item";
            
            taskEl.className = baseClass;
            taskEl.dataset.taskId = task.id;
            
            const ongoingIndicator = task.status === "ongoing" ? 
                '<span class="inline-block w-2 h-2 bg-priority-high rounded-full ongoing-indicator mr-1"></span>' : '';
            
            const countdownBadge = task.countdownText ? `<span class="countdown ml-2">${task.countdownText}</span>` : '';
            
            const timeTextClass = task.status === "ongoing" ? "ongoing-text" : "";
            
            // 使用北京时间显示，对于monthly_interval类型使用getNextOccurrence获取正确时间
            let displayTime;
            if (task.recurrence.type === 'monthly_interval') {
                const nextOccurrence = getNextOccurrence(task, new Date());
                displayTime = nextOccurrence.startTime || new Date();
            } else {
                displayTime = task.startTime || new Date();
            }
            
            const timeDisplay = task.status === 'ongoing' ? '进行中' : 
                              TimeZoneUtils.formatCSTTime(displayTime);
            
            // 添加地点显示
            // 仅为特殊重复规则事件（custom_complex）显示位置信息
            let locationText = '';
            if (task.recurrence.type === "custom_complex" && task.location) {
                // 为破晓红石事件地点添加特殊类
                const isDawnRedstone = task.name === "破晓 红石";
                const locationClass = isDawnRedstone ? "text-xs truncate dawn-redstone-location" : "text-xs text-dark-textSecondary truncate";
                // 处理地点对象，提取区域和名称，格式为：区域-地点名称
                const locationName = typeof task.location === 'object' ? `${task.location.area}-${task.location.name}` : task.location;
                locationText = `<div class="${locationClass}">${locationName}</div>`;
            }
            
            taskEl.innerHTML = `
                <div class="flex items-center flex-1 min-w-0">
                    <span class="w-2 h-2 rounded-full mr-2 bg-priority-${task.priority}"></span>
                    <div class="flex-1 min-w-0">
                        <div class="text-sm truncate">${task.name}</div>
                        <div class="text-xs text-primary flex items-center">
                            ${ongoingIndicator}<span class="${timeTextClass}">${task.timeText || '即将开始'}</span>${countdownBadge}
                        </div>
                        ${locationText}
                    </div>
                </div>
                <div class="text-xs text-dark-textSecondary whitespace-nowrap ml-2">
                    ${timeDisplay}
                </div>
            `;
            
            // 为未来事件列表中的任务添加点击交互
            addClickInteractionToFutureTask(taskEl, task);
            
            taskEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                hideAllContextMenus();
                
                currentTaskId = task.id;
                const x = e.clientX;
                const y = e.clientY;
                
                taskContextMenu.style.left = `${x}px`;
                taskContextMenu.style.top = `${y}px`;
                taskContextMenu.classList.remove('hidden');
            });
            
            return taskEl;
        }

        // 显示预览卡片
        function showPreviewCard(task, x, y) {
            // 先移除所有任务的激活样式
            document.querySelectorAll('.future-task-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // 为当前点击的任务添加激活样式
            const clickedTask = document.querySelector(`.future-task-item[data-task-id="${task.id}"]`);
            if (clickedTask) {
                clickedTask.classList.add('active');
            }
            
            let currentTask = currentAllTasks.find(t => t.id === task.id);
            
            if (!currentTask) return;
            
            // 生成重复方式文本
            let recurrenceText = "";
            // 定义单位名称映射，用于将英文单位转换为中文显示
            const unitNames = {
                "minute": "分钟",
                "hour": "小时",
                "day": "天",
                "week": "周",
                "month": "月"
            };
            if (currentTask.recurrence.type === "custom_complex" && currentTask.recurrence.pattern === "dawn_redstone") {
                recurrenceText = "红石规则";
            } else if (currentTask.recurrence.type === "custom_complex" && currentTask.recurrence.pattern === "dream_skating") {
                recurrenceText = "滑冰规则";
            } else {
                switch(currentTask.recurrence.type) {
                    case "none":
                        recurrenceText = "不重复";
                        break;
                    case "daily":
                        // 显示每天的所有时间点（将太平洋时间转换为北京时间后显示）
                        if (currentTask.recurrence.dailyRepeatType === "time-range" && currentTask.recurrence.rangeStart) {
                            // 时间段间隔模式：显示rangeStart作为开始时间
                            const [startHour, startMinute] = currentTask.recurrence.rangeStart.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            const cstTime = TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            recurrenceText = `每天 ${cstTime}`;
                            
                            // 如果是时间段重复模式且有间隔信息，添加间隔显示
                            if (currentTask.recurrence.intervalCount && currentTask.recurrence.intervalUnit) {
                                const intervalCount = currentTask.recurrence.intervalCount;
                                const intervalUnit = unitNames[currentTask.recurrence.intervalUnit] || "小时";
                                recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                            }
                        } else if (currentTask.recurrence.startTimes && currentTask.recurrence.startTimes.length > 0) {
                            // 特定时间点模式：显示所有时间点
                            const cstTimes = currentTask.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText = `每天 ${cstTimes.join(', ')}`;
                        } else {
                            recurrenceText = "每天";
                        }
                        break;
                    case "weekly":
                        const dayNames = ["日", "一", "二", "三", "四", "五", "六"];
                        const selectedDays = currentTask.recurrence.weekdays?.map(day => dayNames[day]).join(', ') || "";
                        // 显示每周的所有时间点（将太平洋时间转换为北京时间后显示）
                        if (currentTask.recurrence.weeklyRepeatType === "time-points" && currentTask.recurrence.startTimes && currentTask.recurrence.startTimes.length > 0) {
                            // 特定时间点模式
                            const cstTimes = currentTask.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText = `每周 ${selectedDays} ${cstTimes.join(', ')}`;
                        } else if (currentTask.recurrence.weeklyRepeatType === "time-range" && currentTask.recurrence.rangeStart) {
                            // 时间段间隔模式
                            const [startHour, startMinute] = currentTask.recurrence.rangeStart.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            const cstTime = TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            recurrenceText = `每周 ${selectedDays} ${cstTime}`;
                            
                            // 如果有间隔信息，添加间隔显示
                            if (currentTask.recurrence.intervalCount && currentTask.recurrence.intervalUnit) {
                                const intervalCount = currentTask.recurrence.intervalCount;
                                const intervalUnit = unitNames[currentTask.recurrence.intervalUnit] || "小时";
                                recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                            }
                        } else {
                            recurrenceText = `每周 ${selectedDays}`;
                        }
                        break;
                    case "monthly":
                        const monthDayNames = ["周日", "周一", "周二", "周三", "周四", "周五", "周六"];
                        let monthlyDateText = "";
                        if (currentTask.recurrence.weekdays && currentTask.recurrence.weekdays.length > 0) {
                            const selectedWeekDays = currentTask.recurrence.weekdays?.map(day => monthDayNames[day]).join(', ') || "";
                            monthlyDateText = `每月 ${selectedWeekDays}`;
                        } else {
                            // 使用days、monthdays或startDates，支持多个日期
                            const monthdays = (currentTask.recurrence.days && currentTask.recurrence.days.length > 0) ? currentTask.recurrence.days : 
                                              (currentTask.recurrence.monthdays && currentTask.recurrence.monthdays.length > 0) ? currentTask.recurrence.monthdays : 
                                              currentTask.recurrence.startDates;
                            if (monthdays && monthdays.length > 0) {
                                const selectedDays = monthdays.join(', ') || "";
                                monthlyDateText = `每月 ${selectedDays}日`;
                            } else {
                                monthlyDateText = "每月 1日";
                            }
                        }
                        
                        // 显示每月的所有时间点（将太平洋时间转换为北京时间后显示）
                        if (currentTask.recurrence.monthlyRepeatType === "time-points" && currentTask.recurrence.startTimes && currentTask.recurrence.startTimes.length > 0) {
                            // 特定时间点模式
                            const cstTimes = currentTask.recurrence.startTimes.map(timeStr => {
                                const [startHour, startMinute] = timeStr.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                return TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            });
                            recurrenceText = `${monthlyDateText} ${cstTimes.join(', ')}`;
                        } else if (currentTask.recurrence.monthlyRepeatType === "time-range" && currentTask.recurrence.rangeStart) {
                            // 时间段间隔模式
                            const [startHour, startMinute] = currentTask.recurrence.rangeStart.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            const cstTime = TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate));
                            recurrenceText = `${monthlyDateText} ${cstTime}`;
                            
                            // 如果有间隔信息，添加间隔显示
                            if (currentTask.recurrence.intervalCount && currentTask.recurrence.intervalUnit) {
                                const intervalCount = currentTask.recurrence.intervalCount;
                                const intervalUnit = unitNames[currentTask.recurrence.intervalUnit] || "小时";
                                recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                            }
                        } else {
                            recurrenceText = monthlyDateText;
                            
                            // 显示时间（如果有指定）
                            if (currentTask.recurrence.startTime && typeof currentTask.recurrence.startTime === 'string') {
                                // 将太平洋时间转换为北京时间后显示
                                const [startHour, startMinute] = currentTask.recurrence.startTime.split(':').map(Number);
                                const pdtDate = new Date();
                                pdtDate.setHours(startHour, startMinute, 0, 0);
                                recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                            } else if (currentTask.startTime) {
                                // 将太平洋时间转换为北京时间后显示
                                if (typeof currentTask.startTime === 'string') {
                                    const [startHour, startMinute] = currentTask.startTime.split(':').map(Number);
                                    const pdtDate = new Date();
                                    pdtDate.setHours(startHour, startMinute, 0, 0);
                                    recurrenceText += ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                                } else {
                                    recurrenceText += ` ${TimeZoneUtils.formatCSTTime(currentTask.startTime)}`;
                                }
                            }
                        }
                        break;
                    case "interval":
                    case "custom":
                        recurrenceText = `每${currentTask.recurrence.count}${unitNames[currentTask.recurrence.unit]}`;
                        break;
                    case "monthly_interval":
                        const monthUnitNames = {
                            "minute": "分钟",
                            "hour": "小时",
                            "day": "天",
                            "week": "周",
                            "month": "月"
                        };
                        // 显示每月的日期
                        const monthdays = currentTask.recurrence.days && currentTask.recurrence.days.length > 0 ? 
                            currentTask.recurrence.days.join(', ') : "1";
                        // 显示开始时间
                        let startTimeText = "";
                        // monthly_interval模式直接使用task.startTime
                        const startTime = currentTask.startTime;
                        if (startTime && typeof startTime === 'string') {
                            const [startHour, startMinute] = startTime.split(':').map(Number);
                            const pdtDate = new Date();
                            pdtDate.setHours(startHour, startMinute, 0, 0);
                            startTimeText = ` ${TimeZoneUtils.formatCSTTime(TimeZoneUtils.PDTtoCST(pdtDate))}`;
                        }
                        recurrenceText = `每月 ${monthdays}日${startTimeText}`;
                        // 显示间隔信息
                        const intervalCount = currentTask.recurrence.intervalCount || 1;
                        const intervalUnit = monthUnitNames[currentTask.recurrence.intervalUnit] || "小时";
                        recurrenceText += ` 每${intervalCount}${intervalUnit}`;
                        break;
                }
            }
            
            // 生成持续时间文本
            const durationUnitNames = {
                "minute": "分钟",
                "hour": "小时",
                "day": "天",
                "week": "周"
            };
            const durationText = `${currentTask.recurrence.duration}${durationUnitNames[currentTask.recurrence.durationUnit]}`;
            
            // 使用北京时间显示，与createTaskElement保持一致的逻辑
            let displayStartTime;
            // 对所有任务类型使用getNextOccurrence计算下一次发生时间
            const nowCST = new Date();
            const nextOccurrence = getNextOccurrence(currentTask, nowCST);
            displayStartTime = nextOccurrence ? nextOccurrence.startTime : currentTask.startTime;
                                      
            const dateText = TimeZoneUtils.formatCSTDate(displayStartTime);
            let startTimeText, endTimeText;
            
            // 处理时间显示
            // 处理时间显示 - 所有情况都显示具体事件的开始和结束时间
            // 确保displayStartTime是Date对象
            const displayStartTimeObj = typeof displayStartTime === 'string' ? new Date(displayStartTime) : displayStartTime;
            startTimeText = TimeZoneUtils.formatCSTTime(displayStartTimeObj);
            const durationMs = convertToMilliseconds(currentTask.recurrence.duration, currentTask.recurrence.durationUnit);
            const endTime = new Date(displayStartTimeObj.getTime() + durationMs);
            endTimeText = TimeZoneUtils.formatCSTTime(endTime);
            
            const timeRangeText = `${startTimeText} - ${endTimeText}`;
            
            // 生成提醒文本
            const alertText = `提前${currentTask.displayThreshold} ${currentTask.displayThresholdUnit === 'minute' ? '分钟' : currentTask.displayThresholdUnit === 'hour' ? '小时' : currentTask.displayThresholdUnit === 'day' ? '天' : '周'}提醒`;
            
            // 更新预览卡片内容
            document.getElementById('preview-priority').className = `w-2 h-2 rounded-full mr-2 bg-priority-${currentTask.priority}`;
            document.getElementById('preview-name').textContent = currentTask.name;
            
            const statusIndicator = currentTask.status === "ongoing" ? 
                '<span class="inline-block w-2 h-2 bg-priority-high rounded-full ongoing-indicator mr-1"></span>' : '';
            const statusTextClass = currentTask.status === "ongoing" ? "ongoing-text" : "";
            document.getElementById('preview-status').innerHTML = `${statusIndicator}<span class="${statusTextClass}">${currentTask.timeText}</span>`;
            
            document.getElementById('preview-recurrence').textContent = recurrenceText;
            document.getElementById('preview-duration').textContent = `持续 ${durationText}`;
            document.getElementById('preview-date').textContent = dateText;
            document.getElementById('preview-time').textContent = timeRangeText;
            // 为破晓红石事件预览地点添加特殊类
            const previewLocationEl = document.getElementById('preview-location');
            const locationRow = previewLocationEl.closest('.preview-row');
            
            // 检查是否有地点信息
            if (currentTask.location) {
                // 有地点信息时显示地点栏并设置内容
                // 处理地点对象，提取区域和名称，格式为：区域-地点名称
                const locationName = typeof currentTask.location === 'object' ? `${currentTask.location.area}-${currentTask.location.name}` : currentTask.location;
                previewLocationEl.textContent = locationName;
                locationRow.style.display = 'flex';
                
                // 为破晓红石事件添加特殊类
                if (currentTask.name === "破晓 红石") {
                    previewLocationEl.classList.add('dawn-redstone-location');
                } else {
                    previewLocationEl.classList.remove('dawn-redstone-location');
                }
            } else {
                // 没有地点信息时隐藏整个地点栏
                locationRow.style.display = 'none';
            }
            document.getElementById('preview-alert').textContent = alertText;
            
            // 设置卡片位置
            updatePreviewCardPosition(x, y);
            
            // 显示卡片并添加高亮动画
            previewCard.classList.add('show', 'preview-highlight');
            currentPreviewTaskId = currentTask.id;
            isPreviewVisible = true;
        }
        
        // 更新预览卡片位置
        function updatePreviewCardPosition(x, y) {
            const cardWidth = previewCard.offsetWidth;
            const cardHeight = previewCard.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let finalX = x + 15;
            let finalY = y + 15;
            
            // 确保卡片不会超出视口
            if (finalX + cardWidth > viewportWidth - 10) {
                finalX = x - cardWidth - 15;
            }
            if (finalY + cardHeight > viewportHeight - 10) {
                finalY = viewportHeight - cardHeight - 10;
            }
            
            // 确保卡片不会超出视口顶部
            if (finalY < 10) {
                finalY = 10;
            }
            
            previewCard.style.left = `${finalX}px`;
            previewCard.style.top = `${finalY}px`;
        }
        
        // 隐藏预览卡片
        function hidePreviewCard() {
            // 移除所有任务的激活样式
            document.querySelectorAll('.future-task-item').forEach(item => {
                item.classList.remove('active');
            });
            
            previewCard.classList.remove('show', 'preview-highlight');
            currentPreviewTaskId = null;
            isPreviewVisible = false;
        }
        
        // 切换任务列表锁定状态
        function toggleListLock() {
            isListLocked = !isListLocked;
            const icon = lockIndicator.querySelector('i');
            
            if (isListLocked) {
                icon.classList.remove('fa-unlock');
                icon.classList.add('fa-lock');
                lockIndicator.classList.add('locked');
                allTasksEl.style.maxHeight = '500px';
                showNotification('任务列表已锁定显示');
            } else {
                icon.classList.remove('fa-lock');
                icon.classList.add('fa-unlock');
                lockIndicator.classList.remove('locked');
                allTasksEl.style.maxHeight = '0';
                showNotification('任务列表已解锁');
            }
        }

        // 点击展开/折叠未来事件列表
        function toggleFutureEvents() {
            // 切换展开/折叠状态
            if (allTasksEl.style.maxHeight === '500px') {
                allTasksEl.style.maxHeight = '0';
                // 显示词条文本提示器
                showNotification('列表已收起');
            } else {
                allTasksEl.style.maxHeight = '500px';
                // 显示词条文本提示器
                showNotification('列表已展开');
            }
        }

        // 更新事件显示
        function updateTasks() {
            currentVisibleTasks = getVisibleTasks();
            currentAllTasks = getAllTasksWithStatus();
            const hasVisibleContent = currentVisibleTasks.length > 0 || currentAllTasks.length > 0;
            
            // 保存当前滚动位置
            const scrollPosition = window.scrollY || document.documentElement.scrollTop;
            
            taskCarousel.innerHTML = '';
            
            if (currentVisibleTasks.length === 0) {
                taskCarousel.innerHTML = `
                    <div class="text-center py-4 text-dark-textSecondary">
                        目前没有即将开始的事件
                    </div>
                `;
            } else {
                currentVisibleTasks.forEach(task => {
                    const taskEl = createTaskElement(task);
                    taskCarousel.appendChild(taskEl);
                });
            }
            
            updateAllTasksList();
            adjustContainerSize(hasVisibleContent);
            updateSpecialNotification(); // 更新特殊通知
            
            // 优化：只有当用户没有主动滚动时才恢复滚动位置
            // 添加滚动标志，避免在用户主动滚动时强制恢复
            if (!userIsScrolling) {
                setTimeout(() => {
                    const currentScroll = window.scrollY || document.documentElement.scrollTop;
                    // 只有当滚动位置变化较大时才恢复
                    if (Math.abs(currentScroll - scrollPosition) > 20) {
                        window.scrollTo(0, scrollPosition);
                    }
                }, 0);
            }
        }

        // 更新所有事件列表
        function updateAllTasksList() {
            const allTasks = getAllTasksWithStatus();
            allTasksListEl.innerHTML = '';
            
            if (allTasks.length === 0) {
                allTasksListEl.innerHTML = `
                    <div class="text-center py-4 text-dark-textSecondary text-sm">
                        暂无未来事件
                    </div>
                `;
                return;
            }
            
            allTasks.forEach(task => {
                const taskEl = createMiniTaskElement(task);
                allTasksListEl.appendChild(taskEl);
            });
        }

        // 调整容器大小和样式
        function adjustContainerSize(hasContent) {
            if (hasContent) {
                appContainer.classList.remove('app-compact');
                appContainer.classList.add('app-expanded');
                controlsContainer.classList.remove('opacity-0', 'pointer-events-none', 'h-0');
                
                // 移除固定高度，让容器根据实际内容自然调整
                appContainer.style.minHeight = '';
            } else {
                appContainer.classList.remove('app-expanded');
                appContainer.classList.add('app-compact');
                controlsContainer.classList.add('opacity-0', 'pointer-events-none', 'h-0');
                appContainer.style.minHeight = '120px';
            }
        }

        // 显示对应的重复选项面板
        function showRecurrenceOptions(type) {
            
            // 隐藏所有选项面板
            noneOptions.classList.add('hidden');
            dailyOptions.classList.add('hidden');
            weeklyOptions.classList.add('hidden');
            monthlyOptions.classList.add('hidden');
            intervalOptions.classList.add('hidden');
            monthly_intervalOptions.classList.add('hidden');
            
            // 显示对应的选项面板
            if (type === 'none') {
                noneOptions.classList.remove('hidden');
            } else if (type === 'daily') {
                dailyOptions.classList.remove('hidden');
            } else if (type === 'weekly') {
                weeklyOptions.classList.remove('hidden');
            } else if (type === 'monthly') {
                monthlyOptions.classList.remove('hidden');
            } else if (type === 'interval' || type === 'custom') {
                intervalOptions.classList.remove('hidden');
            } else if (type === 'monthly_interval') {
                monthly_intervalOptions.classList.remove('hidden');
            }
        }

        // 验证表单数据
        function validateFormData(recurrenceType) {
            if (recurrenceType === 'daily') {
                const dailyRepeatType = dailyOptions.querySelector('#daily-repeat-type').value;
                if (dailyRepeatType === 'time-points') {
                    const times = dailyOptions.querySelectorAll('.time-input-group .start-time-input');
                    if (times.length === 0 || !times[0].value) {
                        alert('请至少添加一个开始时间');
                        return false;
                    }
                } else {
                    // 时间段重复模式，检查rangeStart、rangeEnd和interval
                    const rangeStart = dailyOptions.querySelector('#daily-range-start').value;
                    const rangeEnd = dailyOptions.querySelector('#daily-range-end').value;
                    const intervalCount = dailyOptions.querySelector('#daily-range-interval').value;
                    
                    if (!rangeStart || !rangeEnd) {
                        alert('请设置时间段的开始和结束时间');
                        return false;
                    }
                    
                    if (rangeStart >= rangeEnd) {
                        alert('开始时间必须早于结束时间');
                        return false;
                    }
                    
                    if (!intervalCount || intervalCount < 1) {
                        alert('请设置有效的间隔时间');
                        return false;
                    }
                }
            } else if (recurrenceType === 'weekly') {
                const checkedDays = Array.from(weeklyOptions.querySelectorAll('input[name="weekday"]')).filter(cb => cb.checked);
                const weeklyRepeatType = weeklyOptions.querySelector('#weekly-repeat-type').value;
                
                if (checkedDays.length === 0) {
                    alert('请至少选择一个星期几');
                    return false;
                }
                
                if (weeklyRepeatType === 'time-points') {
                    const times = weeklyOptions.querySelectorAll('.time-input-group .start-time-input');
                    if (times.length === 0 || !times[0].value) {
                        alert('请至少添加一个开始时间');
                        return false;
                    }
                } else {
                    const rangeStart = weeklyOptions.querySelector('#weekly-range-start').value;
                    const rangeEnd = weeklyOptions.querySelector('#weekly-range-end').value;
                    const intervalCount = weeklyOptions.querySelector('#weekly-range-interval').value;
                    
                    if (!rangeStart || !rangeEnd) {
                        alert('请设置时间段的开始和结束时间');
                        return false;
                    }
                    
                    if (rangeStart >= rangeEnd) {
                        alert('开始时间必须早于结束时间');
                        return false;
                    }
                    
                    if (!intervalCount || intervalCount < 1) {
                        alert('请设置有效的间隔时间');
                        return false;
                    }
                }
            } else if (recurrenceType === 'monthly') {
                const dates = monthlyOptions.querySelectorAll('.date-input-group .start-date-input');
                if (dates.length === 0 || !dates[0].value) {
                    alert('请至少添加一个开始日期');
                    return false;
                }
                const monthlyRepeatType = monthlyOptions.querySelector('#monthly-repeat-type').value;
                if (monthlyRepeatType === 'time-points') {
                    const times = monthlyOptions.querySelectorAll('.time-input-group .start-time-input');
                    if (times.length === 0 || !times[0].value) {
                        alert('请至少添加一个开始时间');
                        return false;
                    }
                } else {
                    const rangeStart = monthlyOptions.querySelector('#monthly-range-start').value;
                    const rangeEnd = monthlyOptions.querySelector('#monthly-range-end').value;
                    const intervalCount = monthlyOptions.querySelector('#monthly-range-interval').value;
                    if (!rangeStart || !rangeEnd) {
                        alert('请设置时间段的开始和结束时间');
                        return false;
                    }
                    if (rangeStart >= rangeEnd) {
                        alert('开始时间必须早于结束时间');
                        return false;
                    }
                    if (!intervalCount || intervalCount < 1) {
                        alert('请设置有效的间隔时间');
                        return false;
                    }
                }
            } else if (recurrenceType === 'interval') {
                const count = parseInt(intervalOptions.querySelector('.interval-count').value) || 0;
                if (count < 1) {
                    alert('间隔计数必须大于0');
                    return false;
                }
                if (!intervalOptions.querySelector('.start-date').value) {
                    alert('请输入开始日期');
                    return false;
                }
                if (!intervalOptions.querySelector('.start-time').value) {
                    alert('请输入开始时间');
                    return false;
                }
            } else if (recurrenceType === 'monthly_interval') {
                const checkedDays = Array.from(monthly_intervalOptions.querySelectorAll('input[name="monthly_interval-day"]')).filter(cb => cb.checked);
                const startTime = monthly_intervalOptions.querySelector('.start-time').value;
                if (checkedDays.length === 0) {
                    alert('请至少选择一个日期');
                    return false;
                }
                if (!startTime) {
                    alert('请输入开始时间');
                    return false;
                }
            }
            
            const threshold = parseInt(displayThresholdInput.value) || 0;
            if (threshold < 1) {
                alert('提前提醒时间必须大于0');
                return false;
            }
            
            const duration = parseInt(document.getElementById('task-duration').value) || 0;
            if (duration < 1) {
                alert('持续时间必须大于0');
                return false;
            }
            
            return true;
        }

        // 添加新事件
        async function addNewTask(taskData) {
            // 为新任务生成唯一id（确保在PostgreSQL integer范围内：-2,147,483,648到2,147,483,647）
            const generateUniqueId = () => {
                // 总是使用当前最大ID+1的方式生成新ID
                const maxId = Math.max(...tasks.map(task => task.id), 0);
                const id = Math.min(maxId + 1, 2147483647);
                
                console.log(`生成的id: ${id}, 类型: ${typeof id}, 是否在范围内: ${id <= 2147483647}`);
                return id;
            };
            const newId = generateUniqueId();
            console.log(`准备创建新任务，id: ${newId}`);
            const duration = parseInt(taskData.duration) || 10;
            const durationUnit = taskData.durationUnit || "minute";
            let newTask = {
                id: newId,
                name: taskData.name,
                displayThreshold: parseInt(taskData.displayThreshold) || 10,
                displayThresholdUnit: taskData.displayThresholdUnit || "minute",
                priority: taskData.priority,
                duration: duration,
                durationUnit: durationUnit,
                location: taskData.location || "",
                recurrence: {
                    duration: duration,
                    durationUnit: durationUnit,
                    type: taskData.recurrenceType
                }
            };
            
            switch(taskData.recurrenceType) {
                case "none":
                    newTask.startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    newTask.startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    break;
                case "daily":
                    newTask.startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    
                    if (taskData.dailyRepeatType === 'time-range') {
                        // 处理时间段重复
                        newTask.recurrence.rangeStart = taskData.rangeStart || '00:00';
                        newTask.recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                        newTask.recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                        newTask.recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                        newTask.recurrence.dailyRepeatType = 'time-range';
                        // 设置初始startTime为时间段开始时间
                        newTask.startTime = newTask.recurrence.rangeStart || '00:00';
                    } else {
                        // 处理时间点重复
                        newTask.recurrence.startTimes = taskData.startTimes || ['00:00'];
                        newTask.recurrence.dailyRepeatType = 'time-points';
                        // 为daily类型任务设置startTime，使用第一个开始时间
                        newTask.startTime = newTask.recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "weekly":
                    newTask.startDate = new Date().toISOString().split('T')[0]; // 使用当前日期作为参考
                    newTask.recurrence.weekdays = taskData.weekdays ? 
                        taskData.weekdays.map(Number) : [1];
                    newTask.recurrence.weeklyRepeatType = taskData.weeklyRepeatType || 'time-points';
                    
                    if (taskData.weeklyRepeatType === 'time-range') {
                        // 处理时间段重复
                        newTask.recurrence.rangeStart = taskData.rangeStart || '00:00';
                        newTask.recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                        newTask.recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                        newTask.recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                        // 设置初始startTime为时间段开始时间
                        newTask.startTime = newTask.recurrence.rangeStart || '00:00';
                    } else {
                        // 处理时间点重复
                        newTask.recurrence.startTimes = taskData.startTimes || ['00:00'];
                        // 为weekly类型任务设置startTime，使用第一个开始时间
                        newTask.startTime = newTask.recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "monthly":
                    newTask.startDate = new Date().toISOString().split('T')[0]; // 使用当前日期作为参考
                    
                    // 处理按日期重复的情况
                    if (taskData.startDates && taskData.startDates.length > 0) {
                        newTask.recurrence.days = taskData.startDates.map(Number);
                        // 如果有日期设置，清除星期几设置
                        delete newTask.recurrence.weekdays;
                    } else {
                        newTask.recurrence.days = [1];
                    }
                    
                    // 处理按星期几重复的情况
                    if (taskData.monthweekdays && taskData.monthweekdays.length > 0) {
                        newTask.recurrence.weekdays = taskData.monthweekdays.map(Number);
                        // 如果有星期几设置，清除日期设置
                        delete newTask.recurrence.days;
                    }
                    
                    // 设置重复类型
                    newTask.recurrence.monthlyRepeatType = taskData.monthlyRepeatType || 'time-points';
                    
                    if (taskData.monthlyRepeatType === 'time-range') {
                        // 处理时间段重复
                        newTask.recurrence.rangeStart = taskData.rangeStart || '00:00';
                        newTask.recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                        newTask.recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                        newTask.recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                        // 设置初始startTime为时间段开始时间
                        newTask.startTime = newTask.recurrence.rangeStart || '00:00';
                    } else {
                        // 处理时间点重复
                        newTask.recurrence.startTimes = taskData.startTimes || ['00:00'];
                        // 为monthly类型任务设置startTime，使用第一个开始时间
                        newTask.startTime = newTask.recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "interval":
                    newTask.startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    newTask.startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    newTask.recurrence.startTime = newTask.startTime;
                    newTask.recurrence.count = parseInt(taskData.intervalCount) || 1;
                    newTask.recurrence.unit = taskData.intervalUnit || "day";
                    // 保存结束日期和时间
                    if (taskData.endDate && taskData.endTime) {
                        newTask.recurrence.endDate = taskData.endDate;
                        newTask.recurrence.endTime = taskData.endTime;
                    }
                    break;
                case "custom":
                    newTask.startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    newTask.startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    newTask.recurrence.startTime = newTask.startTime;
                    newTask.recurrence.count = parseInt(taskData.intervalCount) || 1;
                    newTask.recurrence.unit = taskData.intervalUnit || "day";
                    break;
                case "monthly_interval":
                    newTask.startDate = new Date().toISOString().split('T')[0]; // 使用当前日期作为参考
                    newTask.startTime = taskData.startTime || '00:00';
                    newTask.recurrence.startTime = newTask.startTime;
                    newTask.recurrence.startTimes = [newTask.startTime]; // 添加startTimes数组，兼容云端数据
                    newTask.recurrence.days = taskData.days ? taskData.days.map(Number) : [1];
                    // 同时保存两种字段名，确保admin和index之间的数据兼容性
                    newTask.recurrence.count = parseInt(taskData.intervalCount) || 1;
                    newTask.recurrence.unit = taskData.intervalUnit || "hour";
                    newTask.recurrence.intervalCount = newTask.recurrence.count;
                    newTask.recurrence.intervalUnit = newTask.recurrence.unit;
                    break;
            }
            
            tasks.push(newTask);
            const saveSuccess = await saveData(tasks);
            if (saveSuccess) {
                updateTasks();
            } else {
                tasks.pop();
                alert('添加事件失败，请重试');
            }
        }

        // 更新现有事件
        async function updateExistingTask(taskData) {
            const taskIndex = tasks.findIndex(t => t.id === parseInt(taskData.id));
            if (taskIndex === -1) return;
            
            const originalTask = {...tasks[taskIndex]};
            
            const duration = parseInt(taskData.duration) || 10;
            const durationUnit = taskData.durationUnit || "minute";
            
            tasks[taskIndex].name = taskData.name;
            tasks[taskIndex].displayThreshold = parseInt(taskData.displayThreshold) || 10;
            tasks[taskIndex].displayThresholdUnit = taskData.displayThresholdUnit || "minute";
            tasks[taskIndex].priority = taskData.priority;
            tasks[taskIndex].duration = duration;
            tasks[taskIndex].durationUnit = durationUnit;
            tasks[taskIndex].location = taskData.location || "";
            tasks[taskIndex].recurrence.duration = duration;
            tasks[taskIndex].recurrence.durationUnit = durationUnit;
            tasks[taskIndex].recurrence.type = taskData.recurrenceType;
            
            // 清除之前的重复规则属性，确保所有旧模式的属性都被清除
            delete tasks[taskIndex].recurrence.weekdays;
            delete tasks[taskIndex].recurrence.days;
            delete tasks[taskIndex].recurrence.count;
            delete tasks[taskIndex].recurrence.unit;
            delete tasks[taskIndex].recurrence.startTimes;
            delete tasks[taskIndex].recurrence.startTime;
            delete tasks[taskIndex].recurrence.weeklyRepeatType;
            delete tasks[taskIndex].recurrence.dailyRepeatType;
            delete tasks[taskIndex].recurrence.monthlyRepeatType;
            delete tasks[taskIndex].recurrence.rangeStart;
            delete tasks[taskIndex].recurrence.rangeEnd;
            delete tasks[taskIndex].recurrence.intervalCount;
            delete tasks[taskIndex].recurrence.intervalUnit;
            delete tasks[taskIndex].recurrence.endDate;
            delete tasks[taskIndex].recurrence.endTime;
            delete tasks[taskIndex].recurrence.monthweekdays;
            delete tasks[taskIndex].recurrence.pattern;
            
            // 根据重复类型更新相应的规则
            switch(taskData.recurrenceType) {
                case "none":
                    tasks[taskIndex].startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    tasks[taskIndex].startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    break;
                case "daily":
                    tasks[taskIndex].startDate = taskData.startDate;
                    
                    if (taskData.dailyRepeatType === 'time-range') {
                        // 处理时间段重复
                        tasks[taskIndex].recurrence.rangeStart = taskData.rangeStart || '00:00';
                        tasks[taskIndex].recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                        tasks[taskIndex].recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                        tasks[taskIndex].recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                        tasks[taskIndex].recurrence.dailyRepeatType = 'time-range';
                        tasks[taskIndex].startTime = tasks[taskIndex].recurrence.rangeStart || '00:00';
                    } else {
                        // 处理时间点重复
                        tasks[taskIndex].recurrence.startTimes = taskData.startTimes || ['00:00'];
                        tasks[taskIndex].recurrence.dailyRepeatType = 'time-points';
                        tasks[taskIndex].startTime = tasks[taskIndex].recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "weekly":
                    tasks[taskIndex].recurrence.weekdays = taskData.weekdays ? 
                        taskData.weekdays.map(Number) : [1];
                    
                    // 处理每周重复类型
                    if (taskData.weeklyRepeatType) {
                        tasks[taskIndex].recurrence.weeklyRepeatType = taskData.weeklyRepeatType;
                        
                        // 处理时间段模式
                        if (taskData.weeklyRepeatType === 'time-range') {
                            tasks[taskIndex].recurrence.rangeStart = taskData.rangeStart || '00:00';
                            tasks[taskIndex].recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                            tasks[taskIndex].recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                            tasks[taskIndex].recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                            tasks[taskIndex].startTime = tasks[taskIndex].recurrence.rangeStart;
                        } else {
                            // 处理时间点模式
                            tasks[taskIndex].recurrence.startTimes = taskData.startTimes || ['00:00'];
                            // 为weekly类型任务设置startTime，使用第一个开始时间
                            tasks[taskIndex].startTime = tasks[taskIndex].recurrence.startTimes[0] || '00:00';
                        }
                    } else {
                        // 默认处理时间点模式
                        tasks[taskIndex].recurrence.startTimes = taskData.startTimes || ['00:00'];
                        tasks[taskIndex].startTime = tasks[taskIndex].recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "monthly":
                    // 处理按日期重复的情况
                    if (taskData.startDates && taskData.startDates.length > 0) {
                        tasks[taskIndex].recurrence.days = taskData.startDates.map(Number);
                        // 如果有日期设置，清除星期几设置
                        delete tasks[taskIndex].recurrence.weekdays;
                    } else {
                        tasks[taskIndex].recurrence.days = [1];
                    }
                    
                    // 处理按星期几重复的情况
                    if (taskData.monthweekdays && taskData.monthweekdays.length > 0) {
                        tasks[taskIndex].recurrence.weekdays = taskData.monthweekdays.map(Number);
                        // 如果有星期几设置，清除日期设置
                        delete tasks[taskIndex].recurrence.days;
                    } else {
                        // 如果没有星期几设置，清除它
                        delete tasks[taskIndex].recurrence.weekdays;
                    }
                    
                    // 设置重复类型
                    tasks[taskIndex].recurrence.monthlyRepeatType = taskData.monthlyRepeatType || 'time-points';
                    
                    if (taskData.monthlyRepeatType === 'time-range') {
                        // 处理时间段重复
                        tasks[taskIndex].recurrence.rangeStart = taskData.rangeStart || '00:00';
                        tasks[taskIndex].recurrence.rangeEnd = taskData.rangeEnd || '23:59';
                        tasks[taskIndex].recurrence.intervalCount = parseInt(taskData.intervalCount) || 1;
                        tasks[taskIndex].recurrence.intervalUnit = taskData.intervalUnit || 'hour';
                        // 设置初始startTime为时间段开始时间
                        tasks[taskIndex].startTime = tasks[taskIndex].recurrence.rangeStart || '00:00';
                    } else {
                        // 处理时间点重复
                        tasks[taskIndex].recurrence.startTimes = taskData.startTimes || ['00:00'];
                        // 为monthly类型任务设置startTime，使用第一个开始时间
                        tasks[taskIndex].startTime = tasks[taskIndex].recurrence.startTimes[0] || '00:00';
                    }
                    break;
                case "interval":
                    // 更新根级别的开始日期和时间
                    tasks[taskIndex].startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    tasks[taskIndex].startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    tasks[taskIndex].recurrence.startTime = tasks[taskIndex].startTime;
                    // 更新重复间隔设置
                    tasks[taskIndex].recurrence.count = parseInt(taskData.intervalCount) || 1;
                    tasks[taskIndex].recurrence.unit = taskData.intervalUnit || "day";
                    // 保存结束日期和时间
                    if (taskData.endDate && taskData.endTime) {
                        tasks[taskIndex].recurrence.endDate = taskData.endDate;
                        tasks[taskIndex].recurrence.endTime = taskData.endTime;
                    } else {
                        // 如果没有提供结束日期和时间，清除已有的结束日期和时间
                        delete tasks[taskIndex].recurrence.endDate;
                        delete tasks[taskIndex].recurrence.endTime;
                    }
                    break;
                case "custom":
                    tasks[taskIndex].startDate = taskData.startDate || new Date().toISOString().split('T')[0];
                    tasks[taskIndex].startTime = taskData.startTime || new Date().toTimeString().split(':').slice(0, 2).join(':');
                    tasks[taskIndex].recurrence.count = parseInt(taskData.intervalCount) || 1;
                    tasks[taskIndex].recurrence.unit = taskData.intervalUnit || "day";
                    break;
                case "monthly_interval":
                    tasks[taskIndex].startTime = taskData.startTime || '00:00';
                    tasks[taskIndex].recurrence.startTimes = [tasks[taskIndex].startTime];
                    tasks[taskIndex].recurrence.days = taskData.days ? taskData.days.map(Number) : [1];
                    // 同时保存两种字段名，确保admin和index之间的数据兼容性
                    const intervalCount = parseInt(taskData.intervalCount) || 1;
                    const intervalUnit = taskData.intervalUnit || "hour";
                    tasks[taskIndex].recurrence.count = intervalCount;
                    tasks[taskIndex].recurrence.unit = intervalUnit;
                    tasks[taskIndex].recurrence.intervalCount = intervalCount;
                    tasks[taskIndex].recurrence.intervalUnit = intervalUnit;
                    break;
            }
            
            const saveSuccess = await saveData(tasks);
            if (saveSuccess) {
                updateTasks();
            } else {
                tasks[taskIndex] = originalTask;
                alert('更新事件失败，请重试');
            }
        }

        // 删除事件
        async function deleteTask(taskId) {
            const taskToDelete = tasks.find(t => t.id === taskId);
            if (!taskToDelete) return;
            
            tasks = tasks.filter(task => task.id !== taskId);
            
            const saveSuccess = await saveData(tasks);
            if (saveSuccess) {
                updateTasks();
            } else {
                tasks.push(taskToDelete);
                alert('删除事件失败，请重试');
            }
        }

        // 显示添加事件模态框
        function showAddTaskModal() {
            modalTitle.textContent = "添加新事件";
            taskForm.reset();
            taskIdInput.value = "";
            
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toTimeString().split(':').slice(0, 2).join(':');
            
            // 重置所有开始日期和时间字段
            const noneOptions = document.querySelector('.none-options');
            if (noneOptions) {
                noneOptions.querySelector('.start-date').value = dateStr;
                noneOptions.querySelector('.start-time').value = timeStr;
            }
            
            if (dailyOptions) {
                dailyOptions.querySelector('.start-date').value = dateStr;
                const timeContainer = dailyOptions.querySelector('.time-container');
                timeContainer.innerHTML = '';
                addNewTimeInput(timeContainer, timeStr);
            }
            
            if (weeklyOptions) {
                const timeContainer = weeklyOptions.querySelector('.time-container');
                timeContainer.innerHTML = '';
                addNewTimeInput(timeContainer, timeStr);
            }
            
            if (monthlyOptions) {
                const dateContainer = monthlyOptions.querySelector('.date-container');
                dateContainer.innerHTML = '';
                addNewDateInput(dateContainer, dateStr.split('-')[2] || '1');
                
                // 设置每月重复类型为时间点
                const repeatTypeSelect = monthlyOptions.querySelector('#monthly-repeat-type');
                repeatTypeSelect.value = 'time-points';
                
                // 根据重复类型切换显示
                const timePointsDiv = monthlyOptions.querySelector('#monthly-time-points');
                const timeRangeDiv = monthlyOptions.querySelector('#monthly-time-range');
                const timeContainer = monthlyOptions.querySelector('#monthly-times-container');
                
                // 显示时间点选项，隐藏时间段选项
                timePointsDiv.classList.remove('hidden');
                timeRangeDiv.classList.add('hidden');
                
                // 清空每月时间点容器并添加默认时间
                timeContainer.innerHTML = '';
                const timePointDiv = document.createElement('div');
                timePointDiv.className = 'flex items-center gap-2 mb-2';
                timePointDiv.innerHTML = `
                    <input type="time" class="time-input min-w-[80px] px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" value="${timeStr}">
                    <button type="button" class="remove-time-btn bg-red-500 text-white p-2 rounded hover:bg-red-600 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                `;
                
                // 添加删除事件
                timePointDiv.querySelector('.remove-time-btn').addEventListener('click', () => {
                    timePointDiv.remove();
                });
                
                timeContainer.appendChild(timePointDiv);
            }
            
            if (intervalOptions) {
                intervalOptions.querySelector('.start-date').value = dateStr;
                intervalOptions.querySelector('.start-time').value = timeStr;
            }
            
            displayThresholdInput.value = 10;
            displayThresholdUnitInput.value = "minute";
            taskDurationInput.value = 10;
            durationUnitInput.value = "minute";
            
            recurrenceOptions.forEach(opt => opt.classList.remove('selected'));
            document.querySelector('.recurrence-option[data-type="none"]').classList.add('selected');
            recurrenceTypeInput.value = "none";
            showRecurrenceOptions("none");
            
            taskModal.classList.remove('hidden');
            hideAllContextMenus();
        }

        // 添加新的时间输入框
        function addNewTimeInput(container, value = '') {
            const timeInput = document.createElement('div');
            timeInput.className = 'time-input-group';
            timeInput.innerHTML = `
                <input type="time" value="${value}" class="start-time-input" required>
                <button type="button" class="remove-time-btn" onclick="this.parentElement.remove()">删除</button>
            `;
            container.appendChild(timeInput);
        }

        // 添加新的日期输入框
        function addNewDateInput(container, value = '1') {
            const dateInput = document.createElement('div');
            dateInput.className = 'date-input-group';
            dateInput.innerHTML = `
                <input type="number" min="1" max="31" value="${value}" class="start-date-input" required>
                <button type="button" class="remove-date-btn" onclick="this.parentElement.remove()">删除</button>
            `;
            container.appendChild(dateInput);
        }

        // 显示编辑事件模态框
        function showEditTaskModal(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            modalTitle.textContent = "编辑事件";
            taskIdInput.value = task.id;
            document.getElementById('task-name').value = task.name;
            document.getElementById('task-priority').value = task.priority;
            document.getElementById('task-location').value = task.location || "";
            document.getElementById('task-duration').value = task.recurrence.duration;
            document.getElementById('duration-unit').value = task.recurrence.durationUnit || "minute";
            document.getElementById('display-threshold').value = task.displayThreshold;
            document.getElementById('display-threshold-unit').value = task.displayThresholdUnit || "minute";
            
            const recurrenceType = task.recurrence.type || "none";
            recurrenceOptions.forEach(opt => opt.classList.remove('selected'));
            const selectedOption = document.querySelector(`.recurrence-option[data-type="${recurrenceType}"]`) || 
                                  document.querySelector('.recurrence-option[data-type="none"]');
            selectedOption.classList.add('selected');
            recurrenceTypeInput.value = recurrenceType;
            
            weekdayCheckboxes.forEach(checkbox => checkbox.checked = false);
            monthdayCheckboxes.forEach(checkbox => checkbox.checked = false);
            monthweekdayCheckboxes.forEach(checkbox => checkbox.checked = false);
            
            if (intervalOptions) {
                intervalOptions.querySelector('.interval-count').value = 1;
                intervalOptions.querySelector('.interval-unit').value = "day";
            }
            
            // 设置不重复选项
            if (noneOptions) {
                noneOptions.querySelector('.start-date').value = task.startDate || '';
                noneOptions.querySelector('.start-time').value = task.startTime || '';
            }
            
            // 设置每天选项
            if (dailyOptions) {
                dailyOptions.querySelector('.start-date').value = task.startDate || '';
                const repeatTypeSelect = dailyOptions.querySelector('#daily-repeat-type');
                const timePointsDiv = document.getElementById('daily-time-points');
                const timeRangeDiv = document.getElementById('daily-time-range');
                
                // 根据存储的重复类型显示相应的选项
                if (task.recurrence.dailyRepeatType === 'time-range') {
                    repeatTypeSelect.value = 'time-range';
                    timePointsDiv.classList.add('hidden');
                    timeRangeDiv.classList.remove('hidden');
                    
                    // 设置时间段重复的参数
                    dailyOptions.querySelector('#daily-range-start').value = task.recurrence.rangeStart || '00:00';
                    dailyOptions.querySelector('#daily-range-end').value = task.recurrence.rangeEnd || '23:59';
                    dailyOptions.querySelector('#daily-range-interval').value = task.recurrence.intervalCount || 1;
                    dailyOptions.querySelector('#daily-range-unit').value = task.recurrence.intervalUnit || 'hour';
                } else {
                    repeatTypeSelect.value = 'time-points';
                    timePointsDiv.classList.remove('hidden');
                    timeRangeDiv.classList.add('hidden');
                    
                    // 显示所有设置的时间点，使用task.recurrence.startTimes而不是task.startTime
                    const timeContainer = dailyOptions.querySelector('.time-container');
                    timeContainer.innerHTML = '';
                    const times = Array.isArray(task.recurrence.startTimes) ? task.recurrence.startTimes : [task.startTime];
                    times.forEach(time => addNewTimeInput(timeContainer, time || ''));
                }
            }
            
            // 设置每周选项
            if (weeklyOptions) {
                const timeContainer = weeklyOptions.querySelector('.time-container');
                timeContainer.innerHTML = '';
                
                // 设置重复类型
                const repeatTypeSelect = weeklyOptions.querySelector('#weekly-repeat-type');
                const timePointsDiv = weeklyOptions.querySelector('#weekly-time-points');
                const timeRangeDiv = weeklyOptions.querySelector('#weekly-time-range');
                
                if (task.recurrence.weeklyRepeatType === 'time-range') {
                    repeatTypeSelect.value = 'time-range';
                    timePointsDiv.classList.add('hidden');
                    timeRangeDiv.classList.remove('hidden');
                    
                    // 设置时间段参数
                    if (task.recurrence.rangeStart) {
                        weeklyOptions.querySelector('#weekly-range-start').value = task.recurrence.rangeStart;
                    }
                    if (task.recurrence.rangeEnd) {
                        weeklyOptions.querySelector('#weekly-range-end').value = task.recurrence.rangeEnd;
                    }
                    if (task.recurrence.intervalCount) {
                        weeklyOptions.querySelector('#weekly-range-interval').value = task.recurrence.intervalCount;
                    }
                    if (task.recurrence.intervalUnit) {
                        weeklyOptions.querySelector('#weekly-range-unit').value = task.recurrence.intervalUnit;
                    }
                } else {
                    repeatTypeSelect.value = 'time-points';
                    timePointsDiv.classList.remove('hidden');
                    timeRangeDiv.classList.add('hidden');
                    
                    // 显示所有设置的时间点，使用task.recurrence.startTimes而不是task.startTime
                    const times = Array.isArray(task.recurrence.startTimes) ? task.recurrence.startTimes : [task.startTime];
                    times.forEach(time => addNewTimeInput(timeContainer, time || ''));
                }
                
                if (task.recurrence.weekdays) {
                    task.recurrence.weekdays.forEach(day => {
                        const checkbox = document.querySelector(`input[name="weekday"][value="${day}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            }
            
            // 设置每月选项
            if (monthlyOptions) {
                const dateContainer = monthlyOptions.querySelector('.date-container');
                dateContainer.innerHTML = '';
                // 兼容三种可能的存储方式
                const days = task.recurrence.days || task.recurrence.monthdays || task.recurrence.startDates || [];
                const dayArray = Array.isArray(days) ? days : [days];
                dayArray.forEach(day => addNewDateInput(dateContainer, day || '1'));
                
                // 处理按星期几重复的情况
                if (task.recurrence.weekdays) {
                    task.recurrence.weekdays.forEach(day => {
                        const checkbox = document.querySelector(`input[name="monthweekday"][value="${day}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
                
                // 获取每月重复类型
                const monthlyRepeatType = task.recurrence.monthlyRepeatType || 'time-points';
                
                // 设置重复类型选择器
                const repeatTypeSelect = monthlyOptions.querySelector('#monthly-repeat-type');
                repeatTypeSelect.value = monthlyRepeatType;
                
                // 根据重复类型切换显示
                const timePointsDiv = monthlyOptions.querySelector('#monthly-time-points');
                const timeRangeDiv = monthlyOptions.querySelector('#monthly-time-range');
                const timeContainer = monthlyOptions.querySelector('#monthly-times-container');
                
                if (monthlyRepeatType === 'time-points') {
                    timePointsDiv.classList.remove('hidden');
                    timeRangeDiv.classList.add('hidden');
                    
                    // 显示所有设置的时间点，使用task.recurrence.startTimes而不是task.startTime
                    timeContainer.innerHTML = '';
                    const times = Array.isArray(task.recurrence.startTimes) ? task.recurrence.startTimes : [task.startTime];
                    times.forEach(time => {
                        if (time) {
                            const timePointDiv = document.createElement('div');
                            timePointDiv.className = 'time-input-group flex items-center gap-2 mb-2';
                            timePointDiv.innerHTML = `
                                <input type="time" class="start-time-input min-w-[80px] px-3 py-2 border border-gray-600 rounded-lg bg-dark-bg text-dark-text focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent" value="${time}">
                                <button type="button" class="remove-time-btn text-red-500 hover:text-red-600">
                                    <i class="fa fa-trash"></i>
                                </button>
                            `;
                            
                            // 添加删除事件
                            timePointDiv.querySelector('.remove-time-btn').addEventListener('click', () => {
                                timePointDiv.remove();
                            });
                            
                            timeContainer.appendChild(timePointDiv);
                        }
                    });
                } else {
                    timePointsDiv.classList.add('hidden');
                    timeRangeDiv.classList.remove('hidden');
                    
                    // 设置时间段重复的参数
                    timeRangeDiv.querySelector('#monthly-range-start').value = task.recurrence.rangeStart || '';
                    timeRangeDiv.querySelector('#monthly-range-end').value = task.recurrence.rangeEnd || '';
                    timeRangeDiv.querySelector('#monthly-range-interval').value = task.recurrence.intervalCount || 1;
                    timeRangeDiv.querySelector('#monthly-range-unit').value = task.recurrence.intervalUnit || 'hour';
                }
            }
            
            // 设置间隔选项
            if (intervalOptions) {
                intervalOptions.querySelector('.start-date').value = task.startDate || '';
                intervalOptions.querySelector('.start-time').value = task.startTime || '';
                // 总是设置间隔值，不管当前重复类型是什么
                intervalOptions.querySelector('.interval-count').value = task.recurrence.count || 1;
                intervalOptions.querySelector('.interval-unit').value = task.recurrence.unit || "day";
                
                // 设置结束日期和时间
                intervalOptions.querySelector('.end-date').value = task.recurrence.endDate || '';
                intervalOptions.querySelector('.end-time').value = task.recurrence.endTime || '';
            }
            
            // 设置每月间隔选项
            if (monthly_intervalOptions) {
                monthly_intervalOptions.querySelector('.start-time').value = task.startTime || '';
                // 总是设置间隔值
                // monthly_interval类型需要兼容两种字段名：云端数据使用count/unit，本地数据使用intervalCount/intervalUnit
                const intervalCount = task.recurrence.type === "monthly_interval" ? 
                    (task.recurrence.count || task.recurrence.interval || task.recurrence.intervalCount || 1) : 
                    (task.recurrence.count || 1);
                const intervalUnit = task.recurrence.type === "monthly_interval" ? 
                    (task.recurrence.unit || task.recurrence.intervalUnit || "hour") : 
                    (task.recurrence.unit || "month");
                monthly_intervalOptions.querySelector('#monthly_interval-count').value = intervalCount;
                monthly_intervalOptions.querySelector('#monthly_interval-unit').value = intervalUnit;
                
                // 设置选中的日期
                if (task.recurrence.days) {
                    task.recurrence.days.forEach(day => {
                        const checkbox = monthly_intervalOptions.querySelector(`input[name="monthly_interval-day"][value="${day}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            }
            
            showRecurrenceOptions(recurrenceType);
            taskModal.classList.remove('hidden');
            hideAllContextMenus();
        }

        // 显示确认删除模态框
        function showConfirmDeleteModal(taskId) {
            currentTaskId = taskId;
            confirmDeleteModal.classList.remove('hidden');
            hideAllContextMenus();
        }

        // 隐藏所有右键菜单
        function hideAllContextMenus() {
            mainContextMenu.classList.add('hidden');
            taskContextMenu.classList.add('hidden');
        }

        // 隐藏事件模态框
        function hideTaskModal() {
            taskModal.classList.add('hidden');
        }

        // 隐藏确认删除模态框
        function hideConfirmDeleteModal() {
            confirmDeleteModal.classList.add('hidden');
        }

        // 下载为HTML文件功能
        function downloadAsHtml() {
            try {
                const dataToSave = { tasks: tasks };
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = document.documentElement.outerHTML;
                
                const elementsWithStyles = tempDiv.querySelectorAll('[style]');
                elementsWithStyles.forEach(el => {
                    if (el.style.transform) {
                        const transform = el.style.transform;
                        el.removeAttribute('style');
                        el.style.transform = transform;
                    } else {
                        el.removeAttribute('style');
                    }
                });
                
                const appContainer = tempDiv.querySelector('#app-container');
                if (appContainer) {
                    appContainer.className = 'bg-dark-card rounded-2xl shadow-lg task-transition border border-gray-700 w-auto max-w-md app-compact';
                }
                
                const scripts = tempDiv.querySelectorAll('script');
                scripts.forEach(script => {
                    if (script.textContent.includes('let externalData = null;')) {
                        const newContent = script.textContent.replace(
                            'let externalData = null;',
                            `let externalData = ${JSON.stringify(dataToSave, null, 2)};`
                        );
                        script.textContent = newContent;
                    }
                });
                
                const body = tempDiv.querySelector('body');
                if (body) {
                    body.className = 'bg-dark-bg min-h-screen flex items-center justify-center p-4 font-inter text-dark-text m-0';
                }
                
                const updatedHtml = '<!DOCTYPE html>' + tempDiv.innerHTML;
                
                const blob = new Blob([updatedHtml], { 
                    type: 'text/html; charset=utf-8' 
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                a.download = `Sky 事件 时间_${dateStr}.html`;
                
                a.href = url;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 0);
                
                showNotification('数据已导出为HTML文件');
            } catch (e) {
                console.error('下载失败:', e);
                showNotification('导出HTML文件失败: ' + e.message, true);
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', async () => {
            // 首先从外部JSON文件加载硬编数据
            hardcodedTasksData = await loadHardcodedTasks();
            
            if (hardcodedTasksData.length > 0) {
                // 使用硬编数据初始化tasks
                tasks = hardcodedTasksData;
            } else {
                // 如果加载失败，显示警告
                showNotification('硬编数据加载失败，将使用空数据', true);
            }
            
            // 初始化日期和时间输入
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toTimeString().split(':').slice(0, 2).join(':');
            
            startDateInput.value = dateStr;
            startTimeInput.value = timeStr;
            
            // 初始化主题管理器
            const themeManager = new ThemeManager();
            
            // 绑定主题切换按钮 - 重新获取元素确保DOM已加载
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', () => {
                    themeManager.toggleTheme();
                });
            }
            
            // 添加时间和日期输入的辅助函数
            function addTimeInputHandler() {
                const timeContainer = this.parentElement.querySelector('.time-container');
                addNewTimeInput(timeContainer);
            }

            function addDateInputHandler() {
                const dateContainer = this.parentElement.querySelector('.date-container');
                addNewDateInput(dateContainer);
            }

            // 添加重复类型切换事件监听器（每天重复）
            const dailyRepeatTypeSelect = document.getElementById('daily-repeat-type');
            if (dailyRepeatTypeSelect) {
                dailyRepeatTypeSelect.addEventListener('change', function() {
                    const timePointsDiv = document.getElementById('daily-time-points');
                    const timeRangeDiv = document.getElementById('daily-time-range');
                    if (this.value === 'time-points') {
                        timePointsDiv.classList.remove('hidden');
                        timeRangeDiv.classList.add('hidden');
                    } else {
                        timePointsDiv.classList.add('hidden');
                        timeRangeDiv.classList.remove('hidden');
                    }
                });
            }

            // 添加重复类型切换事件监听器（每周重复）
            const weeklyRepeatTypeSelect = document.getElementById('weekly-repeat-type');
            if (weeklyRepeatTypeSelect) {
                weeklyRepeatTypeSelect.addEventListener('change', function() {
                    const timePointsDiv = document.getElementById('weekly-time-points');
                    const timeRangeDiv = document.getElementById('weekly-time-range');
                    if (this.value === 'time-points') {
                        timePointsDiv.classList.remove('hidden');
                        timeRangeDiv.classList.add('hidden');
                    } else {
                        timePointsDiv.classList.add('hidden');
                        timeRangeDiv.classList.remove('hidden');
                    }
                });
            }
            
            // 添加重复类型切换事件监听器（每月重复）
            const monthlyRepeatTypeSelect = document.getElementById('monthly-repeat-type');
            if (monthlyRepeatTypeSelect) {
                monthlyRepeatTypeSelect.addEventListener('change', function() {
                    const timePointsDiv = document.getElementById('monthly-time-points');
                    const timeRangeDiv = document.getElementById('monthly-time-range');
                    if (this.value === 'time-points') {
                        timePointsDiv.classList.remove('hidden');
                        timeRangeDiv.classList.add('hidden');
                    } else {
                        timePointsDiv.classList.add('hidden');
                        timeRangeDiv.classList.remove('hidden');
                    }
                });
            }

            // 为所有添加时间按钮添加事件监听器
            const addTimeButtons = document.querySelectorAll('.add-time-btn');
            addTimeButtons.forEach(button => {
                button.addEventListener('click', addTimeInputHandler);
            });

            // 为所有添加日期按钮添加事件监听器
            const addDateButtons = document.querySelectorAll('.add-date-btn');
            addDateButtons.forEach(button => {
                button.addEventListener('click', addDateInputHandler);
            });

            // 初始化重复选项点击事件
            recurrenceOptions.forEach(option => {
                option.addEventListener('click', () => {
                    recurrenceOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    const type = option.getAttribute('data-type');
                    recurrenceTypeInput.value = type;
                    showRecurrenceOptions(type);
                });
            });
            
            // 异步加载数据，不阻塞UI
            (async () => {
                // 检查是否有外部数据并加载
                const savedData = await loadFromSupabase();
                if (savedData && Array.isArray(savedData)) {
                    // 如果返回的是数组，直接赋值给tasks
                    tasks = savedData;
                } else if (savedData && savedData.tasks) {
                    // 兼容旧数据格式
                    tasks = savedData.tasks;
                } else {
                    // 保存初始任务列表
                    await saveData(tasks);
                }
                
                // 数据加载完成后更新任务列表、特殊通知和魔法图标
                updateTasks();
                updateSpecialNotification();
                initMagicIcons(); // 重新初始化魔法图标，使用最新的云端数据
            })();
            
            // 页面初始化时预检测图片并预加载，减少用户点击按钮时的等待时间
            (() => {
                // 异步检测图片，不阻塞页面加载
                detectTPImages().then(tpImages => {
                    console.log('图片预检测完成，已缓存结果，开始预加载图片');
                    
                    // 预加载图片内容
                    if (tpImages && tpImages.length > 0) {
                        // 只预加载前5张图片，避免一次性加载过多
                        const imagesToPreload = tpImages.slice(0, 5);
                        
                        imagesToPreload.forEach(imageName => {
                            if (imageName.startsWith('local_')) {
                                // 本地缓存图片，无需预加载
                                return;
                            }
                            
                            // 预加载本地图片
                            const localImg = new Image();
                            localImg.src = `./images/Sky/${imageName}`;
                            
                            // 预加载云端图片
                            const cloudImg = new Image();
                            const githubRepo = 'sky-event/sky-event.github.io';
                            const githubImageBaseUrl = `https://raw.githubusercontent.com/${githubRepo}/main/163/images/Sky`;
                            cloudImg.src = `${githubImageBaseUrl}/${imageName}`;
                        });
                        
                        console.log('预加载完成，已缓存前5张图片');
                    }
                }).catch(err => {
                    console.log('图片预检测失败:', err);
                });
            })();
            
            // 检测Sky文件夹中的图片 - 使用自动检测机制，添加缓存优化
            // 使用var声明确保变量提升
            var tpImagesCache = null; // 缓存检测结果
            function detectTPImages() {
                // 如果已经缓存了结果，直接返回
                if (tpImagesCache) {
                    return Promise.resolve(tpImagesCache);
                }
                
                return new Promise((resolve) => {
                    const maxImages = 10; // 最多检测10张图片
                    const foundImages = Array(maxImages * 2).fill(null); // 创建固定长度数组
                    let checked = 0;
                    let totalToCheck = maxImages * 2; // 同时检查PNG和WEBP格式
                    
                    // 检测数字命名的图片（如1.png, 1.jpg, 2.png, 2.jpg等）
                    for (let i = 1; i <= maxImages; i++) {
                        // 检测PNG格式
                        const pngImageName = `${i}.png`;
                        const pngImg = new Image();
                        pngImg.onload = () => {
                            foundImages[(i - 1) * 2] = pngImageName; // 按序号放入对应位置
                            checked++;
                            if (checked === totalToCheck) {
                                addLocalImagesAndResolve();
                            }
                        };
                        pngImg.onerror = () => {
                            checked++;
                            if (checked === totalToCheck) {
                                addLocalImagesAndResolve();
                            }
                        };
                        pngImg.src = `./images/Sky/${pngImageName}?t=${Date.now()}`; // 加时间戳防止缓存
                        
                        // 检测WEBP格式
                        const webpImageName = `${i}.webp`;
                        const webpImg = new Image();
                        webpImg.onload = () => {
                            foundImages[(i - 1) * 2 + 1] = webpImageName; // 按序号放入对应位置
                            checked++;
                            if (checked === totalToCheck) {
                                addLocalImagesAndResolve();
                            }
                        };
                        webpImg.onerror = () => {
                            checked++;
                            if (checked === totalToCheck) {
                                addLocalImagesAndResolve();
                            }
                        };
                        webpImg.src = `./images/Sky/${webpImageName}?t=${Date.now()}`; // 加时间戳防止缓存
                    }
                    
                    // 添加本地缓存图片并返回结果
                    function addLocalImagesAndResolve() {
                        // 过滤出有效的图片
                        const validImages = foundImages.filter(img => img !== null);
                        
                        // 从localStorage中加载用户添加的本地图片
                        const localImages = [];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key.startsWith('sky_local_image_')) {
                                const fileName = key.replace('sky_local_image_', '');
                                localImages.push(fileName);
                            }
                        }
                        
                        // 将本地图片添加到结果列表
                        const finalImages = [...validImages, ...localImages];
                        // 缓存检测结果
                        tpImagesCache = finalImages;
                        resolve(finalImages);
                    }
                });
            }

            // 初始化按钮事件 - 已在拉花喷射效果的script标签中绑定
            manualSaveBtn.addEventListener('click', () => {
                // 检查是否已经有模态框存在
                const existingModal = document.getElementById('large-wax-modal');
                if (existingModal) {
                    // 如果存在，直接关闭
                    const modalContent = existingModal.querySelector('.relative');
                    const image = existingModal.querySelector('img');
                    
                    // 添加淡出过渡效果
                    existingModal.style.opacity = '0';
                    modalContent.style.transform = 'scale(0.9)';
                    image.style.opacity = '0';
                    
                    // 等待动画完成后再移除元素
                    setTimeout(() => {
                        existingModal.remove();
                    }, 300);
                } else {
                    // 如果不存在，显示新的图片
                    detectTPImages().then(tpImages => {
                        showLargeWaxImages(tpImages, 'Sky', 'Sky');
                    });
                }
            });
            
            // 初始化未来事件列表点击展开/折叠事件
            emptyHoverArea.addEventListener('click', toggleFutureEvents);
            
            // 为右键菜单选项添加点击事件
            addTaskOption.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (await validatePassword()) {
                    showAddTaskModal();
                } else {
                    showNotification('密码错误，无法添加任务', true);
                }
            });

            editTaskOption.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (currentTaskId !== null) {
                    if (await validatePassword()) {
                        showEditTaskModal(currentTaskId);
                    } else {
                        showNotification('密码错误，无法编辑任务', true);
                    }
                }
            });

            deleteTaskOption.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (currentTaskId !== null) {
                    if (await validatePassword()) {
                        showConfirmDeleteModal(currentTaskId);
                    } else {
                        showNotification('密码错误，无法删除任务', true);
                    }
                }
            });
            
            // 点击其他地方隐藏预览卡片
            document.addEventListener('click', (e) => {
                // 如果点击的不是预览卡片本身，也不是未来事件列表中的任务，则关闭预览卡片
                if (!previewCard.contains(e.target) && !e.target.closest('.future-task-item')) {
                    hidePreviewCard();
                }
            });
            
            // 保持原有的鼠标移动跟踪以实现丝滑跟随
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                if (isPreviewVisible) {
                    updatePreviewCardPosition(mouseX, mouseY);
                }
            });
            
            // 应用容器右键菜单事件
            appContainer.addEventListener('contextmenu', (e) => {
                if (!e.target.closest('.task-item') && !e.target.closest('[data-task-id]')) {
                    e.preventDefault();
                    hideAllContextMenus();
                    
                    const x = e.clientX;
                    const y = e.clientY;
                    
                    mainContextMenu.style.left = `${x}px`;
                    mainContextMenu.style.top = `${y}px`;
                    mainContextMenu.classList.remove('hidden');
                }
            });

            // 点击其他地方隐藏右键菜单
            document.addEventListener('click', hideAllContextMenus);

            // 关闭模态框事件
            closeModal.addEventListener('click', (e) => {
                e.stopPropagation();
                hideTaskModal();
            });
            
            cancelTask.addEventListener('click', (e) => {
                e.stopPropagation();
                hideTaskModal();
            });
            
            taskModal.querySelector('.modal-backdrop').addEventListener('click', (e) => {
                e.stopPropagation();
                hideTaskModal();
            });

            // 关闭确认删除模态框事件
            closeDeleteModal.addEventListener('click', (e) => {
                e.stopPropagation();
                hideConfirmDeleteModal();
            });
            
            cancelDelete.addEventListener('click', (e) => {
                e.stopPropagation();
                hideConfirmDeleteModal();
            });
            
            confirmDeleteModal.querySelector('.modal-backdrop').addEventListener('click', (e) => {
                e.stopPropagation();
                hideConfirmDeleteModal();
            });

            // 确认删除事件
            confirmDelete.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (currentTaskId !== null) {
                    // 密码验证
                    if (await validatePassword()) {
                        await deleteTask(currentTaskId);
                        currentTaskId = null;
                        hideConfirmDeleteModal();
                    }
                }
            });

            // 更新任务显示
            updateTasks();
            
            // 数据加载完成，显示应用
            setTimeout(() => {
                const loadingIndicator = document.getElementById('loading-indicator');
                const appContainer = document.getElementById('app-container');
                
                if (loadingIndicator) {
                    loadingIndicator.style.opacity = '0';
                    setTimeout(() => {
                        loadingIndicator.style.display = 'none';
                    }, 500);
                }
                
                if (appContainer) {
                    appContainer.style.opacity = '1';
                    appContainer.style.transform = 'translateY(0)';
                }
            }, 200);
            
            // 表单提交事件
            taskForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // 密码验证
                if (!(await validatePassword())) {
                    return;
                }
                
                // 获取表单数据
                const recurrenceType = recurrenceTypeInput.value;
                let formData = {
                    id: document.getElementById('task-id').value,
                    name: document.getElementById('task-name').value,
                    displayThreshold: document.getElementById('display-threshold').value,
                    displayThresholdUnit: document.getElementById('display-threshold-unit').value,
                    priority: document.getElementById('task-priority').value,
                    recurrenceType: recurrenceType,
                    duration: document.getElementById('task-duration').value,
                    durationUnit: document.getElementById('duration-unit').value,
                    location: document.getElementById('task-location').value
                };
                
                // 根据重复类型获取相应的时间和日期数据
                if (recurrenceType === 'none') {
                    formData.startDate = noneOptions.querySelector('.start-date').value;
                    formData.startTime = noneOptions.querySelector('.start-time').value;
                } else if (recurrenceType === 'daily') {
                    formData.startDate = dailyOptions.querySelector('.start-date').value;
                    const dailyRepeatType = dailyOptions.querySelector('#daily-repeat-type').value;
                    
                    if (dailyRepeatType === 'time-points') {
                        formData.startTimes = Array.from(dailyOptions.querySelectorAll('.time-input-group .start-time-input'))
                            .map(input => input.value)
                            .filter(value => value);
                        formData.dailyRepeatType = 'time-points';
                    } else {
                        // 收集时间段重复的数据
                        formData.dailyRepeatType = 'time-range';
                        formData.rangeStart = dailyOptions.querySelector('#daily-range-start').value;
                        formData.rangeEnd = dailyOptions.querySelector('#daily-range-end').value;
                        formData.intervalCount = dailyOptions.querySelector('#daily-range-interval').value;
                        formData.intervalUnit = dailyOptions.querySelector('#daily-range-unit').value;
                    }
                } else if (recurrenceType === 'weekly') {
                    formData.weekdays = Array.from(weeklyOptions.querySelectorAll('input[name="weekday"]'))
                        .filter(cb => cb.checked)
                        .map(cb => parseInt(cb.value));
                    
                    // 根据每周重复类型收集数据
                    const weeklyRepeatType = weeklyOptions.querySelector('#weekly-repeat-type').value;
                    if (weeklyRepeatType === 'time-points') {
                        // 收集特定时间点重复的数据
                        formData.startTimes = Array.from(weeklyOptions.querySelectorAll('.time-input-group .start-time-input'))
                            .map(input => input.value)
                            .filter(value => value);
                        formData.weeklyRepeatType = 'time-points';
                    } else {
                        // 收集时间段重复的数据
                        formData.weeklyRepeatType = 'time-range';
                        formData.rangeStart = weeklyOptions.querySelector('#weekly-range-start').value;
                        formData.rangeEnd = weeklyOptions.querySelector('#weekly-range-end').value;
                        formData.intervalCount = weeklyOptions.querySelector('#weekly-range-interval').value;
                        formData.intervalUnit = weeklyOptions.querySelector('#weekly-range-unit').value;
                    }
                } else if (recurrenceType === 'monthly') {
                    formData.startDates = Array.from(monthlyOptions.querySelectorAll('.date-input-group .start-date-input'))
                        .map(input => parseInt(input.value))
                        .filter(value => value > 0 && value <= 31);
                    
                    // 收集每月重复类型
                    const monthlyRepeatType = monthlyOptions.querySelector('#monthly-repeat-type').value;
                    formData.monthlyRepeatType = monthlyRepeatType;
                    
                    // 根据重复类型收集不同的数据
                    if (monthlyRepeatType === 'time-points') {
                        // 收集特定时间点重复的数据
                        formData.startTimes = Array.from(monthlyOptions.querySelectorAll('.time-input-group .start-time-input'))
                            .map(input => input.value)
                            .filter(value => value);
                    } else {
                        // 收集时间段重复的数据
                        formData.rangeStart = monthlyOptions.querySelector('#monthly-range-start').value;
                        formData.rangeEnd = monthlyOptions.querySelector('#monthly-range-end').value;
                        formData.intervalCount = monthlyOptions.querySelector('#monthly-range-interval').value;
                        formData.intervalUnit = monthlyOptions.querySelector('#monthly-range-unit').value;
                    }
                    
                    // 收集按星期几重复的数据
                    formData.monthweekdays = Array.from(document.querySelectorAll('input[name="monthweekday"]'))
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                } else if (recurrenceType === 'interval' || recurrenceType === 'custom') {
                    formData.startDate = intervalOptions.querySelector('.start-date').value;
                    formData.startTime = intervalOptions.querySelector('.start-time').value;
                    formData.intervalCount = intervalOptions.querySelector('.interval-count').value;
                    formData.intervalUnit = intervalOptions.querySelector('.interval-unit').value;
                    
                    // 收集结束日期和时间
                    if (recurrenceType === 'interval') {
                        formData.endDate = intervalOptions.querySelector('.end-date').value;
                        formData.endTime = intervalOptions.querySelector('.end-time').value;
                    }
                } else if (recurrenceType === 'monthly_interval') {
                    formData.startTime = monthly_intervalOptions.querySelector('.start-time').value;
                    formData.days = Array.from(monthly_intervalOptions.querySelectorAll('input[name="monthly_interval-day"]'))
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    formData.intervalCount = monthly_intervalOptions.querySelector('#monthly_interval-count').value;
                    formData.intervalUnit = monthly_intervalOptions.querySelector('#monthly_interval-unit').value;
                }
                
                if (!validateFormData(formData.recurrenceType)) {
                    return;
                }
                
                if (formData.id) {
                    await updateExistingTask(formData);
                } else {
                    await addNewTask(formData);
                }
                
                hideTaskModal();
            });

            // 初始化显示
            updateCurrentTime();
            updateTasks();
            
            // 初始化魔法图标
            initMagicIcons();

        });
        
        // 魔法图标配置
        const magicIconsConfig = {
            0: [ // 星期日
                { name: '今日 体型重塑', png: 'txcs.png' },
                { name: '今日 彩虹魔法', png: 'chmf.png' }
            ],
            1: [ // 星期一
                { name: '今日 浪漫烟花', png: 'lmyh.png' }
            ],
            2: [ // 星期二
                { name: '今日 充能药剂', png: 'cnyj.png' }
            ],
            3: [ // 星期三
                { name: '今日 璀璨之星', png: 'cczx.png' }
            ],
            4: [ // 星期四
                { name: '今日 漂浮魔法', png: 'pfmf.png' }
            ],
            5: [ // 星期五
                { name: '今日魔法 小不点', png: 'xbd.png' },
                { name: '今日免费魔法 大只佬', png: 'dzl.png' }
            ],
            6: [ // 星期六
                { name: '今日 返老还童', png: 'flht.png' },
                { name: '今日 长大成人', png: 'zdcr.png' }
            ]
        };
        
        // 初始化魔法图标
        function initMagicIcons() {
            const container = document.getElementById('magic-icons-container');
            const today = new Date().getDay(); // 获取今天是星期几 (0-6)
            const magicIcons = magicIconsConfig[today] || [];
            const now = new Date(); // 声明当前时间变量，供所有地方使用
            
            // 保存当前容器状态，以便在出现问题时恢复
            const originalContent = container.innerHTML;
            
            try {
                // 清空容器
                container.innerHTML = '';
                
                // 添加魔法图标
                // 检查事件Id25是否在生效的有效期内
                const event25 = tasks.find(task => task.id === 25);
                let isEvent25Active = false;
                
                console.log('双倍魔法调试：当前时间', now);  // 新增调试日志
                console.log('双倍魔法调试：找到的事件25', event25);  // 新增调试日志
                
                if (event25) {
                    // 计算事件Id25的有效期
                    const startTime = new Date(`${event25.startDate}T${event25.startTime}`);
                    const durationMs = convertToMilliseconds(event25.recurrence.duration, event25.recurrence.durationUnit);
                    const endTime = new Date(startTime.getTime() + durationMs);
                    
                    console.log('双倍魔法调试：开始时间', startTime);  // 新增调试日志
                    console.log('双倍魔法调试：结束时间', endTime);  // 新增调试日志
                    console.log('双倍魔法调试：持续时间(ms)', durationMs);  // 新增调试日志
                    
                    // 检查当前时间是否在事件有效期内
                    isEvent25Active = now >= startTime && now < endTime;
                    console.log('双倍魔法调试：事件是否激活', isEvent25Active);  // 新增调试日志
                }
                
                // 如果事件Id25生效，则显示sb.png，否则显示当天的魔法图标
                if (isEvent25Active) {
                    // 创建双倍魔法图标
                    const iconElement = document.createElement('div');
                    iconElement.className = 'magic-icon-item cursor-pointer relative';
                    iconElement.title = '双倍魔法';
                    iconElement.innerHTML = `
                        <div style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background-color: transparent; border: none; border-radius: 8px; overflow: visible;">
                            <img src="./icons/sb.png" alt="双倍魔法" 
                                 style="width: 32px; height: 32px; object-fit: contain; transition: transform 0.2s ease;" 
                                 class="magic-icon hover:scale-110" 
                                 onerror="this.src='./icons/zh.png'; this.alt='双倍魔法';" />
                        </div>
                    `;
                    
                    // 添加点击事件，显示双倍魔法通知并执行拉花喷射
                    iconElement.addEventListener('click', () => {
                        showNotification('双倍666魔法');
                        // 执行拉花喷射效果
                        spraySpots();
                    });
                    
                    // 添加到容器
                    container.appendChild(iconElement);
                } else {
                    // 正常显示当天的魔法图标
                    magicIcons.forEach(magic => {
                        const iconElement = document.createElement('div');
                        iconElement.className = 'magic-icon-item cursor-pointer relative';
                        iconElement.title = magic.name;
                        iconElement.innerHTML = `
                            <div style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background-color: transparent; border: none; border-radius: 8px; overflow: visible;">
                                <img src="./icons/${magic.png}" alt="${magic.name}" 
                                     style="width: 32px; height: 32px; object-fit: contain; transition: transform 0.2s ease;" 
                                     class="magic-icon hover:scale-110" 
                                     onerror="this.src='./icons/zh.png'; this.alt='魔法图标';" />
                            </div>
                        `;
                        
                        // 添加点击事件，显示魔法名称
                        iconElement.addEventListener('click', () => {
                            showNotification(magic.name);
                        });
                        
                        // 直接添加到容器
                        container.appendChild(iconElement);
                    });
                }
                
                // 添加季蜡图标 - 每天切换一个地图，顺序：云野, 雨林, 霞谷, 暮土, 禁阁
                const seasonWaxMaps = ['云野', '雨林', '霞谷', '暮土', '禁阁'];
                const currentDate = new Date();
                
                // 计算2025年11月27日应该显示霞谷（索引2）
                // 计算当天是一年中的第几天
                const dayOfYear = Math.floor((currentDate - new Date(currentDate.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
                
                // 添加偏移量确保2025年11月27日显示霞谷
                // 2025年11月27日是第331天，331 % 5 = 1（对应雨林），需要偏移+1到索引2（霞谷）
                const offset = 1;
                const mapIndex = (dayOfYear + offset) % seasonWaxMaps.length;
                const currentMap = seasonWaxMaps[mapIndex];
                
                // 检查jl.png是否存在，如不存在则使用默认图标
                const seasonWaxElement = document.createElement('div');
                seasonWaxElement.className = 'magic-icon-item cursor-pointer relative';
                seasonWaxElement.title = `今日季蜡位置: ${currentMap}`;
                seasonWaxElement.innerHTML = `
                    <div style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background-color: transparent; border: none; border-radius: 8px; overflow: visible; margin-top: 8px;">
                        <img src="./icons/jl.png" alt="季蜡" 
                             style="width: 32px; height: 32px; object-fit: contain; transition: transform 0.2s ease;" 
                             class="magic-icon hover:scale-110" 
                             onerror="this.src='./icons/zh.png'; this.alt='季蜡';" />
                    </div>
                    <div style="text-align: center; font-size: 10px; color: var(--text-color); margin-top: 2px; font-weight: 500; width: 100%;">
                        ${currentMap}
                    </div>
                `;
                
                // 添加点击事件，显示季蜡位置
                seasonWaxElement.addEventListener('click', () => {
                    showNotification(`今天季蜡在  ${currentMap} 哦!`);
                });
                
                // 直接添加到容器
                container.appendChild(seasonWaxElement);
                
                // 添加大蜡图标 - 每天切换不同地图组合
                // 正确策略：周一到周日的大蜡位置
                const largeWaxMaps = [
                    { locations: ['霞谷'], name: '霞谷', fullName: '霞谷' },                          // 周一 (l1)
                    { locations: ['暮土'], name: '暮土', fullName: '暮土' },                          // 周二 (l2)
                    { locations: ['禁阁'], name: '禁阁', fullName: '禁阁' },                          // 周三 (l3)
                    { locations: ['云野'], name: '云野', fullName: '云野' },                          // 周四 (l4)
                    { locations: ['云野', '雨林', '霞谷'], name: '云野,雨林,霞谷', fullName: '云野,雨林,霞谷' },  // 周五 (l5)
                    { locations: ['云野', '雨林', '暮土'], name: '云野,雨林,暮土', fullName: '云野,雨林,暮土' },  // 周六 (l6)
                    { locations: ['雨林', '暮土', '禁阁'], name: '雨林,暮土,禁阁', fullName: '雨林,暮土,禁阁' }   // 周日 (l7)
                ];
                
                // 自动检测图片数量的函数 - 支持GitHub API和本地图片
                function detectImages(dayIndex) {
                    return new Promise((resolve) => {
                        const folderName = `l${dayIndex + 1}`;
                        const maxImages = 3; // 最多检测3张图片
                        const foundImages = Array(maxImages).fill(null); // 创建固定长度数组
                        let checked = 0;
                        
                        // GitHub Pages 配置
                        const githubRepo = 'sky-event/sky-event.github.io';
                        const githubPath = `163/images/${folderName}`;
                        
                        // 先尝试从GitHub API获取图片列表
                        fetch(`https://api.github.com/repos/${githubRepo}/contents/${githubPath}`)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('GitHub API请求失败');
                                }
                                return response.json();
                            })
                            .then(files => {
                                // 处理GitHub API返回的文件列表
                                files.forEach(file => {
                                    // 支持PNG和WEBP格式
                                    if (file.name.endsWith('.png') || file.name.endsWith('.webp')) {
                                        // 提取数字部分
                                        const numStr = file.name.match(/^(\d+)\.(png|webp)$/);
                                        if (numStr) {
                                            const index = parseInt(numStr[1]) - 1;
                                            if (index >= 0 && index < maxImages) {
                                                foundImages[index] = file.name;
                                            }
                                        }
                                    }
                                });
                                // 过滤出有效的图片
                                const validImages = foundImages.filter(img => img !== null);
                                if (validImages.length > 0) {
                                    resolve(validImages);
                                } else {
                                    // 如果GitHub没有图片，尝试本地图片
                                    checkLocalImages();
                                }
                            })
                            .catch(error => {
                                console.log('GitHub API失败，尝试本地图片:', error);
                                // GitHub API失败，尝试本地图片
                                checkLocalImages();
                            });
                        
                        // 检测本地数字命名的图片（如1.png, 2.webp等）
                        function checkLocalImages() {
                            // 同时检测PNG和WEBP格式
                            const extensions = ['.png', '.webp'];
                            let totalChecks = maxImages * extensions.length;
                            
                            for (let i = 1; i <= maxImages; i++) {
                                extensions.forEach(ext => {
                                    const imageName = `${i}${ext}`;
                                    const img = new Image();
                                    img.onload = () => {
                                        // 如果该位置还没有图片，设置为当前图片
                                        if (!foundImages[i - 1]) {
                                            foundImages[i - 1] = imageName;
                                        }
                                        checked++;
                                        if (checked === totalChecks) {
                                            // 过滤掉不存在的图片
                                            resolve(foundImages.filter(img => img !== null));
                                        }
                                    };
                                    img.onerror = () => {
                                        checked++;
                                        if (checked === totalChecks) {
                                            // 过滤掉不存在的图片
                                            resolve(foundImages.filter(img => img !== null));
                                        }
                                    };
                                    img.src = `./images/${folderName}/${imageName}?t=${Date.now()}`; // 加时间戳防止缓存
                                });
                            }
                        }
                    });
                }
                
                // 设置起始日期：太平洋时间2024年12月8日（周日）
                const startDate = new Date(Date.UTC(2024, 11, 8)); // 月份是0-11，所以11代表12月
                
                // 将当前时间转换为北京时间（东八区）
                // 创建UTC时间对象
                const currentUTC = new Date(Date.UTC(
                    currentDate.getFullYear(),
                    currentDate.getMonth(),
                    currentDate.getDate()
                ));
                
                // 转换为北京时间 (UTC+8)
                const currentBeijingTime = new Date(currentUTC.getTime() + 8 * 60 * 60 * 1000);
                
                // 获取北京时间的星期几 (0=周日, 1=周一...6=周六)
                const beijingDayOfWeek = currentBeijingTime.getUTCDay();
                
                // 计算索引：周一=0, 周二=1...周日=6
                const adjustedDayOfWeek = beijingDayOfWeek === 0 ? 6 : beijingDayOfWeek - 1;
                const currentLargeWax = largeWaxMaps[adjustedDayOfWeek];
                
                // 检查事件Id24是否在生效的有效期内
                let isEvent24Active = false;
                
                // 从合并后的tasks数组获取事件Id24的实际数据（优先使用云数据）
                const event24 = tasks.find(task => task.id === 24);
                if (event24) {
                    // 计算事件Id24的有效期
                    const startTime = new Date(`${event24.startDate}T${event24.startTime}`);
                    const durationMs = convertToMilliseconds(event24.recurrence.duration, event24.recurrence.durationUnit);
                    const endTime = new Date(startTime.getTime() + durationMs);
                    
                    // 检查当前时间是否在事件有效期内
                    isEvent24Active = now >= startTime && now < endTime;
                }
                
                // 创建大蜡图标元素
                const largeWaxElement = document.createElement('div');
                largeWaxElement.className = 'magic-icon-item cursor-pointer relative';
                
                // 根据事件Id24状态设置显示内容
                let displayLocation = currentLargeWax.locations.length === 1 ? currentLargeWax.locations[0] : currentLargeWax.locations.map(loc => loc.charAt(0)).join(' ');
                if (isEvent24Active) {
                    displayLocation = '全图';
                    largeWaxElement.title = `今日大蜡位置: ${displayLocation}`;
                } else {
                    largeWaxElement.title = `今日大蜡位置: ${currentLargeWax.name}`;
                }
                
                largeWaxElement.innerHTML = `
                    <div style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background-color: transparent; border: none; border-radius: 8px; overflow: visible; margin-top: 8px;">
                        <img src="./icons/dl.png" alt="大蜡" 
                             style="width: 32px; height: 32px; object-fit: contain; transition: transform 0.2s ease;" 
                             class="magic-icon hover:scale-110" 
                             onerror="this.src='./icons/zh.png'; this.alt='大蜡';" />
                    </div>
                    <div style="text-align: center; font-size: 10px; color: var(--text-color); margin-top: 2px; font-weight: 500; width: 100%;">
                        ${displayLocation}
                    </div>
                `;
                
                // 添加点击事件处理
                if (isEvent24Active) {
                    // 事件Id24生效时，点击执行拉花喷射效果
                    largeWaxElement.addEventListener('click', () => {
                        showNotification(`快跑啊! ${displayLocation}大蜡来了!`);
                        // 执行拉花喷射效果
                        spraySpots();
                    });
                } else {
                    // 普通情况，显示大蜡位置
                    largeWaxElement.addEventListener('click', () => {
                        showNotification(`今日大蜡位置: ${currentLargeWax.fullName}`);
                    });
                    
                    // 异步检测大蜡图片
                    detectImages(adjustedDayOfWeek).then(images => {
                        currentLargeWax.images = images;
                        
                        // 如果有图片，重新添加点击事件以支持图片查看
                        if (images.length > 0) {
                            // 重新获取大蜡图标元素
                            const containerLargeWaxElement = container.querySelector('.magic-icon-item:last-child');
                            if (containerLargeWaxElement) {
                                // 移除现有点击事件
                                containerLargeWaxElement.replaceWith(containerLargeWaxElement.cloneNode(true));
                                const newLargeWaxElement = container.querySelector('.magic-icon-item:last-child');
                                
                                // 添加新的点击事件，支持图片查看
                                newLargeWaxElement.addEventListener('click', () => {
                                    showNotification(`今日大蜡位置: ${currentLargeWax.fullName}`);
                                    // 显示图片卡片，传入文件夹名称（l1到l7，对应周一到周日）
                                    const folderName = `l${adjustedDayOfWeek + 1}`;
                                    showLargeWaxImages(currentLargeWax.images, currentLargeWax.fullName, folderName);
                                });
                            }
                        }
                    }).catch(error => {
                    });
                }
                
                // 直接添加到容器
                container.appendChild(largeWaxElement);
            } catch (error) {
                console.error('魔法图标初始化失败:', error);
                // 如果初始化失败，恢复容器原始内容
                container.innerHTML = originalContent;
            }
        }

        // 更新当前时间显示
        function updateCurrentTime() {
            const now = new Date();
            currentTimeEl.textContent = now.toLocaleTimeString('zh-CN', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        // 获取中国标准时间（CST）
        function getCurrentTimeCST() {
            const now = new Date();
            // 使用toLocaleString将时间转换为Asia/Shanghai时区
            const cstTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Shanghai' }));
            return cstTime;
        }
        
        // 用户滚动状态管理
        let userIsScrolling = false;
        let scrollTimeout;
        
        // 监听用户滚动事件
        window.addEventListener('scroll', () => {
            userIsScrolling = true;
            
            // 清除之前的定时器
            clearTimeout(scrollTimeout);
            
            // 300ms后重置滚动标志
            scrollTimeout = setTimeout(() => {
                userIsScrolling = false;
            }, 300);
        });

        // 每秒更新时间
        setInterval(updateCurrentTime, 1000);
        
        // 每秒更新一次事件状态，保持事件状态的及时更新
        setInterval(updateTasks, 1000);
        
        // 跨天自动刷新功能已关闭 - 不再基于太平洋时间进行跨天检查
        
        // 注册Service Worker
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
              .then((registration) => {
                console.log('Service Worker 注册成功:', registration.scope);
              })
              .catch((error) => {
                console.log('Service Worker 注册失败:', error);
              });
          });
        }

        // 破晓红石地点推算函数
        function getDawnRedstoneLocation(date, dayOfWeek) {
            const dayOfMonth = date.getDate();
            
            // 暮土系 (日期: 1,6,11,16,21,26,31)
            if ([1, 6, 11, 16, 21, 26, 31].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return { area: "暮土", name: "黑水港湾" };
                if (dayOfWeek === 6) return { area: "暮土", name: "巨兽荒原" };
                if (dayOfWeek === 0) return { area: "暮土", name: "失落方舟" };
            }
            
            // 禁阁系 (日期: 2,7,12,17,22,27)
            if ([2, 7, 12, 17, 22, 27].includes(dayOfMonth)) {
                if ([5, 6, 0].includes(dayOfWeek)) return { area: "禁阁", name: "星漠海滩" };
            }
            
            // 云野系 (日期: 3,8,13,18,23,28)
            if ([3, 8, 13, 18, 23, 28].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return { area: "云野", name: "云顶浮石" };
                if (dayOfWeek === 6) return { area: "云野", name: "幽光山洞" };
                if (dayOfWeek === 0) return { area: "云野", name: "圣岛" };
            }
            
            // 雨林系 (日期: 4,9,14,19,24,29)
            if ([4, 9, 14, 19, 24, 29].includes(dayOfMonth)) {
                if (dayOfWeek === 5) return { area: "雨林", name: "大树屋" };
                if (dayOfWeek === 6) return { area: "雨林", name: "雨林神庙" };
                if (dayOfWeek === 0) return { area: "雨林", name: "秘密花园" };
            }
            
            // 霞谷系 (日期: 5,10,15,20,25,30)
            if ([5, 10, 15, 20, 25, 30].includes(dayOfMonth)) {
                if ([5, 6].includes(dayOfWeek)) return { area: "霞谷", name: "圆梦村" };
                if (dayOfWeek === 0) return { area: "霞谷", name: "雪隐峰" };
            }
            
            return null;
        }
        
        // 破晓黑石地点推算函数
        function getDawnBlackstoneLocation(date, dayOfWeek) {
            const dayOfMonth = date.getDate();
            
            // 暮土系 (日期: 1,6,11,16,21,26,31)
            if ([1, 6, 11, 16, 21, 26, 31].includes(dayOfMonth)) {
                if (dayOfWeek === 2 && dayOfMonth <= 15) return { area: "暮土", name: "边陲荒漠" };
                if (dayOfWeek === 3 && dayOfMonth >= 16) return { area: "暮土", name: "远古战场" };
            }
            
            // 禁阁系 (日期: 2,7,12,17,22,27)
            if ([2, 7, 12, 17, 22, 27].includes(dayOfMonth)) {
                if (dayOfWeek === 2 && dayOfMonth <= 15) return { area: "禁阁", name: "星光沙漠" };
                if (dayOfWeek === 3 && dayOfMonth >= 16) return { area: "禁阁", name: "星光沙漠" };
            }
            
            // 云野系 (日期: 3,8,13,18,23,28)
            if ([3, 8, 13, 18, 23, 28].includes(dayOfMonth)) {
                if (dayOfWeek === 2 && dayOfMonth <= 15) return { area: "云野", name: "蝴蝶平原" };
                if (dayOfWeek === 3 && dayOfMonth >= 16) return { area: "云野", name: "云野仙乡" };
            }
            
            // 雨林系 (日期: 4,9,14,19,24,29)
            if ([4, 9, 14, 19, 24, 29].includes(dayOfMonth)) {
                if (dayOfWeek === 2 && dayOfMonth <= 15) return { area: "雨林", name: "荧光森林" };
                if (dayOfWeek === 3 && dayOfMonth >= 16) return { area: "雨林", name: "密林遗迹" };
            }
            
            // 霞谷系 (日期: 5,10,15,20,25,30)
            if ([5, 10, 15, 20, 25, 30].includes(dayOfMonth)) {
                if (dayOfWeek === 2 && dayOfMonth <= 15) return { area: "霞谷", name: "滑冰场" };
                if (dayOfWeek === 3 && dayOfMonth >= 16) return { area: "霞谷", name: "滑冰场" };
            }
            
            return null;
        }
        
        // 获取破晓红石事件时间段（用于图标显示）
        function getDawnRedstoneTimeSlotsForIcons(date, dayOfWeek) {
            const dayOfMonth = date.getDate();
            const slots = [];
            
            // 周日事件
            if (dayOfWeek === 0) {
                slots.push(
                    { start: "07:08", end: "08:00" },
                    { start: "13:08", end: "14:00" },
                    { start: "19:08", end: "20:00" }
                );
            }
            
            // 周六事件 (1-15号)
            if (dayOfWeek === 6 && dayOfMonth >= 1 && dayOfMonth <= 15) {
                slots.push(
                    { start: "10:08", end: "11:00" },
                    { start: "14:08", end: "15:00" },
                    { start: "22:08", end: "23:00" }
                );
            }
            
            // 周五事件 (16号到月底)
            if (dayOfWeek === 5 && dayOfMonth >= 16) {
                slots.push(
                    { start: "11:08", end: "12:00" },
                    { start: "17:08", end: "18:00" },
                    { start: "23:08", end: "24:00" }
                );
            }
            
            return slots;
        }
        
        // 获取破晓黑石事件时间段（用于图标显示）
        function getDawnBlackstoneTimeSlotsForIcons(date, dayOfWeek) {
            const dayOfMonth = date.getDate();
            const slots = [];
            
            // 星期二事件 (上半月1-15日)
            if (dayOfWeek === 2 && dayOfMonth <= 15) {
                slots.push(
                    { start: "09:08", end: "10:00" },
                    { start: "14:08", end: "15:00" },
                    { start: "19:08", end: "20:00" }
                );
            }
            
            // 星期三事件 (下半月16-31日)
            if (dayOfWeek === 3 && dayOfMonth >= 16) {
                slots.push(
                    { start: "09:08", end: "10:00" },
                    { start: "15:08", end: "16:00" },
                    { start: "21:08", end: "22:00" }
                );
            }
            
            return slots;
        }

        // 获取最近的红石或黑石事件
        function getNearestEvent(eventType) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            // 最多查找未来7天的事件
            for (let i = 0; i < 7; i++) {
                const checkDate = new Date(today);
                checkDate.setDate(today.getDate() + i);
                const dayOfWeek = checkDate.getDay();
                
                let slots, location;
                if (eventType === 'redstone') {
                    slots = getDawnRedstoneTimeSlotsForIcons(checkDate, dayOfWeek);
                    location = getDawnRedstoneLocation(checkDate, dayOfWeek);
                } else {
                    slots = getDawnBlackstoneTimeSlotsForIcons(checkDate, dayOfWeek);
                    location = getDawnBlackstoneLocation(checkDate, dayOfWeek);
                }
                
                if (slots.length > 0 && location) {
                    // 查找当天未结束的最近事件
                    for (const slot of slots) {
                        const [startHour, startMinute] = slot.start.split(':');
                        const [endHour, endMinute] = slot.end.split(':');
                        
                        const eventStart = new Date(checkDate);
                        eventStart.setHours(parseInt(startHour), parseInt(startMinute));
                        
                        const eventEnd = new Date(checkDate);
                        eventEnd.setHours(parseInt(endHour), parseInt(endMinute));
                        
                        // 如果事件尚未开始或正在进行，返回该事件
                        if (now <= eventEnd) {
                            return {
                                date: checkDate,
                                timeSlot: slot,
                                location: location,
                                dayOffset: i
                            };
                        }
                    }
                }
            }
            
            return null;
        }

        // 创建事件图标
        function createEventIcon(eventType) {
            const container = document.getElementById('redstone-blackstone-container');
            const nearestEvent = getNearestEvent(eventType);
            
            if (nearestEvent) {
                const { date, timeSlot, location, dayOffset } = nearestEvent;
                
                // 确定显示文本
                let displayText;
                switch (dayOffset) {
                    case 0: displayText = '今天'; break;
                    case 1: displayText = '明天'; break;
                    case 2: displayText = '后天'; break;
                    default: displayText = `${dayOffset}天后`;
                }
                
                // 确定图标和名称
                const iconName = eventType === 'redstone' ? 'hong' : 'hei';
                const eventName = eventType === 'redstone' ? '红石' : '黑石';
                
                // 创建图标元素
                const iconElement = document.createElement('div');
                iconElement.className = 'magic-icon-item cursor-pointer relative';
                iconElement.title = `${eventName}：${date.getDate()}号 ${timeSlot.start} ${location.area}-${location.name}`;
                iconElement.innerHTML = `
                    <div style="width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background-color: transparent; border: none; border-radius: 8px; overflow: visible;">
                        <img src="./icons/${iconName}.png" alt="${eventName}" 
                             style="object-fit: contain; transition: transform 0.2s ease;" 
                             class="magic-icon hover:scale-110" 
                             onerror="this.src='./icons/zh.png'; this.alt='${eventName}';" />
                    </div>
                    <div style="text-align: center; font-size: 10px; color: var(--text-color); margin-top: 2px; font-weight: 500; width: 100%;">
                        ${displayText}
                    </div>
                `;
                
                // 添加点击事件
                iconElement.addEventListener('click', () => {
                    const dateStr = date.getDate();
                    showNotification(`${eventName}: ${dateStr}号 ${timeSlot.start} ${location.area}-${location.name}`);
                });
                
                container.appendChild(iconElement);
            }
        }

        // 初始化红石黑石图标
        function initRedstoneBlackstoneIcons() {
            const container = document.getElementById('redstone-blackstone-container');
            container.innerHTML = ''; // 清空容器
            
            // 创建红石图标
            createEventIcon('redstone');
            
            // 创建黑石图标
            createEventIcon('blackstone');
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', initRedstoneBlackstoneIcons);
    </script>
</body>
</html>